<!doctype html>
<html lang="ru">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Генеалогия — custom</title>
<style>
:root{
  --bg:#0b1220; --panel:#111a2b; --line:#24324d; --txt:#e8eef9; --muted:#9fb0cc;
  --graph-bg:#0a1324; --edge:#87a4d4;
  --node:#b8a8ff; --node-stroke:#8f74ff;
  --male:#9cc8ff; --male-stroke:#3b82f6;
  --female:#f8b4d8; --female-stroke:#db2777;
  --node-key:#93c5fd; --node-key-stroke:#2563eb;
  --node-mention:#fdba74; --node-mention-stroke:#ea580c;
}
*{box-sizing:border-box}
html,body{height:100%}
body{margin:0;font-family:Inter,Segoe UI,Arial,sans-serif;background:linear-gradient(180deg,#0b1220,#0f1728);color:var(--txt)}
header{padding:10px 16px;border-bottom:1px solid var(--line);background:#0b1220eb;backdrop-filter:blur(6px);position:sticky;top:0;z-index:20}
.headerRow{display:flex;align-items:center;gap:12px;min-width:0;white-space:nowrap;overflow:hidden}
h1{margin:0;font-size:16px;flex:0 1 auto;min-width:0;overflow:hidden;text-overflow:ellipsis}
.titleShort{display:none}
.meta{margin-top:0;font-size:12px;color:var(--muted);overflow:hidden;text-overflow:ellipsis}
#meta{flex:0 1 36%}
#version{flex:1 1 auto;opacity:.88}

@media(max-width:900px){
  header{padding:8px 10px}
  .headerRow{gap:8px}
  .titleLong{display:none}
  .titleShort{display:inline}
  h1{font-size:14px;flex:0 0 auto}
  #meta{display:none}
  #version{font-size:11px}
}
@media(max-width:560px){
  h1{max-width:40vw}
}
.layout{display:grid;grid-template-columns:280px 1fr 370px;gap:10px;padding:10px;height:calc(100vh - 68px)}
.panel{border:1px solid var(--line);background:var(--panel);border-radius:12px;overflow:hidden;min-height:0;display:flex;flex-direction:column}
.panel h2{margin:0;padding:9px 12px;border-bottom:1px solid var(--line);font-size:13px;color:#c6d6f2;display:flex;justify-content:space-between;align-items:center;gap:8px}
.content{padding:10px;overflow:auto;min-height:0;flex:1}
input{width:100%;padding:9px 10px;border-radius:9px;border:1px solid #294063;background:#0c1628;color:#e8eef9}
.item{margin-top:6px;border:1px solid #253754;background:#0d1728;padding:8px;border-radius:9px;cursor:pointer}
.item.active{border-color:#67b0ff;background:#10203a}
.small{font-size:12px;color:var(--muted)}

/* visible scrollbars */
.content::-webkit-scrollbar{width:10px;height:10px}
.content::-webkit-scrollbar-track{background:#0b1527;border-radius:8px}
.content::-webkit-scrollbar-thumb{background:#35507a;border-radius:8px}
.content::-webkit-scrollbar-thumb:hover{background:#4a6ea8}

#graphHost{position:relative;height:100%;background:var(--graph-bg);border-radius:8px;border:1px solid #253b5f;overflow:hidden;overscroll-behavior:none}
#graphSvg{position:absolute;inset:0;width:100%;height:100%;user-select:none}
.legend{display:flex;gap:10px;align-items:center;flex-wrap:wrap}
.legend span{display:inline-flex;align-items:center;gap:5px;font-size:11px;color:#cbd8ef}
.dot{width:10px;height:10px;border-radius:50%}
.ctrls{display:flex;gap:6px;align-items:center;flex-wrap:wrap}
.btn{font-size:12px;padding:4px 8px;border-radius:8px;border:1px solid #3b4c6a;background:#101a2d;color:#d9e7ff;cursor:pointer}
.btn:hover{border-color:#67b0ff;color:#fff}
.hint{position:absolute;left:8px;bottom:8px;background:#0b1220cf;color:#d9e7ff;font-size:11px;padding:4px 7px;border-radius:6px;pointer-events:none}

svg text{font-family:Arial,sans-serif}
.node rect{rx:10;ry:10;stroke-width:1.4;cursor:pointer}
.node:hover rect{stroke-width:2.2}

.row{margin:8px 0}
.k{font-size:11px;color:#9cb1d6;text-transform:uppercase;letter-spacing:.04em}
.v{margin-top:3px;white-space:pre-wrap;word-break:break-word}
a{color:#8ec7ff}
pre{white-space:pre-wrap;background:#0b1423;border:1px solid #24324d;border-radius:8px;padding:8px;font-size:12px;line-height:1.35;max-height:380px;overflow:auto}
details summary{cursor:pointer;color:#b9cef4;font-size:12px}

@media(max-width:1300px){.layout{grid-template-columns:250px 1fr 330px}}
@media(max-width:1100px){.layout{grid-template-columns:1fr;height:auto}.panel{height:64vh}}
</style>
</head>
<body>
<header>
  <div class="headerRow">
    <h1><span class="titleLong">Генеалогия (custom renderer с нуля, без Graphviz)</span><span class="titleShort">Генеалогия</span></h1>
    <div class="meta" id="meta">Загрузка...</div>
    <div class="meta" id="version"></div>
  </div>
</header>

<div class="layout">
  <section class="panel">
    <h2><span>Люди</span><span class="small" id="listCount"></span></h2>
    <div class="content">
      <input id="q" placeholder="Поиск: имя / фамилия / ID" />
      <div id="list"></div>
    </div>
  </section>

  <section class="panel">
    <h2>
      <span>Связи</span>
      <div class="ctrls">
        <button class="btn" id="fitBtn">Fit</button>
        <button class="btn" id="zoomInBtn">+</button>
        <button class="btn" id="zoomOutBtn">−</button>
        <button class="btn" id="centerBtn">Center selected</button>
      </div>
    </h2>
    <div class="content" style="padding:8px;display:flex;flex-direction:column;gap:8px;overflow:hidden">
      <div class="legend" id="legend">
        <span><i class="dot" style="background:var(--node-key)"></i> Эд + мама + её родители</span>
        <span><i class="dot" style="background:var(--node-mention)"></i> Минадора/Фоманида/Фомаида/Федора</span>
        <span><i class="dot" style="background:var(--female)"></i> Женщины</span>
        <span><i class="dot" style="background:var(--male)"></i> Мужчины</span>
        <span style="margin-left:12px;opacity:.7">Линии окрашены по семьям</span>
      </div>
      <div id="graphHost">
        <svg id="graphSvg"></svg>
        <div class="hint">ЛКМ drag — pan · 2 пальца на трекпаде — pan · pinch или Cmd/Ctrl+колесо — zoom</div>
      </div>
    </div>
  </section>

  <section class="panel">
    <h2>Карточка + все поля</h2>
    <div class="content" id="details">Выбери человека</div>
  </section>
</div>

<script>
let DATA, MAP={}, PEOPLE=[], FAMS=[], selected=null;
let graph=null; // {xy,nodeW,nodeH,worldW,worldH}
let view={x:0,y:0,w:100,h:100};

// Manual build marker: updates on each publish commit.
const APP_VERSION='20260224_2003';
const APP_BUILT_AT_ISO='2026-02-24T20:03:00+02:00';

const elMeta=document.getElementById('meta');
const elVersion=document.getElementById('version');
const elList=document.getElementById('list');
const elQ=document.getElementById('q');
const elDetails=document.getElementById('details');
const elCount=document.getElementById('listCount');
const host=document.getElementById('graphHost');
const svg=document.getElementById('graphSvg');

const fitBtn=document.getElementById('fitBtn');
const zoomInBtn=document.getElementById('zoomInBtn');
const zoomOutBtn=document.getElementById('zoomOutBtn');
const centerBtn=document.getElementById('centerBtn');

const esc=s=>(s??'').toString().replace(/[&<>\"]/g,c=>({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;'}[c]));

function formatAgo(ts){
  const ms=Math.max(0, Date.now()-ts.getTime());
  const m=Math.floor(ms/60000);
  if(m<1) return 'только что';
  if(m<60) return `${m} мин назад`;
  const h=Math.floor(m/60);
  if(h<24) return `${h} ч назад`;
  const d=Math.floor(h/24);
  return `${d} дн назад`;
}

function renderVersionInfo(){
  const cb = new URLSearchParams(location.search).get('cache_bust');
  const compact = window.matchMedia('(max-width:900px)').matches;
  const builtAt=new Date(APP_BUILT_AT_ISO);
  const builtAgo = Number.isNaN(builtAt.getTime()) ? 'неизвестно' : formatAgo(builtAt);

  elVersion.textContent = compact
    ? `v${APP_VERSION} · ${builtAgo}`
    : `Версия: ${APP_VERSION} · Обновлено: ${builtAgo}${cb?` · cache_bust=${cb}`:''}`;

  // Live server marker (CDN edge): show relative age too.
  fetch(window.location.href, { method:'HEAD', cache:'no-store' })
    .then(r=>{
      const lm=r.headers.get('last-modified');
      if(!lm) return;
      const d=new Date(lm);
      if(Number.isNaN(d.getTime())) return;
      elVersion.textContent += compact ? ` · srv ${formatAgo(d)}` : ` · Сервер: ${formatAgo(d)}`;
    })
    .catch(()=>{});
}


function renderList(arr){
  elCount.textContent = `${arr.length}/${PEOPLE.length}`;
  elList.innerHTML='';
  arr.forEach(p=>{
    const d=document.createElement('div');
    d.className='item'+(selected===p.id?' active':'');
    d.dataset.id=p.id;
    d.innerHTML=`<div><b>${esc(p.name||p.name_raw||p.id)}</b></div><div class='small'>${p.id}${p.surname?(' · '+esc(p.surname)):''}</div>`;
    d.onclick=()=>select(p.id,true);
    elList.appendChild(d);
  });
}

function fmtEvents(arr){
  if(!arr||!arr.length) return '—';
  return arr.map(e=>`${esc(e.date||'')} ${e.place?('· '+esc(e.place)):''} ${e.note?('('+esc(e.note)+')'):''}`).join('<br>');
}

function links(ids){
  if(!ids||!ids.length) return '<span class="small">—</span>';
  return ids.map(id=>`<a href='#' data-j='${id}' class='j'>${id} — ${esc((MAP[id]?.name)||MAP[id]?.name_raw||'')}</a>`).join('<br>');
}

function renderDetails(id){
  const p=MAP[id]; if(!p) return;
  selected=id;

  const hasEvents=(arr)=>Array.isArray(arr) && arr.some(e=> (e.date||e.place||e.note||'').trim());
  const row=(title,val)=>`<div class='row'><div class='k'>${title}</div><div class='v'>${val}</div></div>`;

  let html=`
    <div class='row'><b style='font-size:18px'>${esc(p.name||p.name_raw||id)}</b></div>
    <div class='row small'>${esc(p.id)} ${p.sex?(' · '+esc(p.sex)):''} ${p.rin?(' · RIN '+esc(p.rin)):''}</div>
    ${row('Рождение', fmtEvents(p.birth))}
    ${hasEvents(p.death) ? row('Смерть', fmtEvents(p.death)) : ''}
    ${hasEvents(p.burial) ? row('Погребение', fmtEvents(p.burial)) : ''}
    ${hasEvents(p.residence) ? row('Проживание', fmtEvents(p.residence)) : ''}
    ${row('Родители', links(p.parents))}
    ${p.children?.length ? row('Дети', links(p.children)) : ''}
    ${p.spouses?.length ? row('Супруги', links(p.spouses)) : ''}
    <div class='row'><details><summary>RAW GEDCOM (все поля)</summary><pre>${esc(p.raw||'')}</pre></details></div>
  `;

  elDetails.innerHTML=html;
  elDetails.querySelectorAll('.j').forEach(a=>a.onclick=(e)=>{e.preventDefault(); select(a.dataset.j,true);});
}

function shortName(raw,id,max=24){
  const n=(raw||id||'').replaceAll('/','').trim();
  return n.length>max ? (n.slice(0,max-1)+'…') : n;
}

function splitName2(raw,id,maxLine=16){
  const full=(raw||id||'').replaceAll('/','').trim();
  const words=full.split(/\s+/).filter(Boolean);
  if(!words.length) return [id,''];
  let l1='', l2='';
  for(const w of words){
    if((l1 ? l1+' '+w : w).length <= maxLine){
      l1 = l1 ? (l1+' '+w) : w;
    } else {
      l2 = (l2 ? l2+' '+w : w);
    }
  }
  if(!l2 && l1.length > maxLine){
    l2 = l1.slice(maxLine-1);
    l1 = l1.slice(0,maxLine-1);
  }
  if(l2.length > maxLine+2) l2 = l2.slice(0,maxLine+1)+'…';
  return [l1, l2];
}

function years(p){
  const b=(p.birth&&p.birth[0]&&p.birth[0].date)||'';
  const d=(p.death&&p.death[0]&&p.death[0].date)||'';
  const y=s=>{const m=(s||'').match(/(\d{4})/); return m?m[1]:''};
  const by=y(b), dy=y(d);
  if(!by && !dy) return '';
  return `${by||'?'}—${dy||''}`;
}

function buildGraphModel(){
  const parents=new Map(), children=new Map();
  PEOPLE.forEach(p=>{parents.set(p.id,new Set()); children.set(p.id,new Set());});

  FAMS.forEach(f=>{
    const ps=[...(f.husband||[]), ...(f.wife||[])].filter(id=>MAP[id]);
    const ch=(f.children||[]).filter(id=>MAP[id]);
    ps.forEach(p=>ch.forEach(c=>{children.get(p).add(c); parents.get(c).add(p);}));
  });

  // === GENERATION ASSIGNMENT relative to Ed (I1) ===
  // Gen 0 = Ed, +1 = parents, +2 = grandparents, etc.
  // This ensures same-generation relatives align on one row.
  const ROOT_ID = MAP['I1'] ? 'I1' : PEOPLE[0]?.id;
  const gen=new Map();
  gen.set(ROOT_ID, 0);
  const q=[ROOT_ID];
  while(q.length){
    const u=q.shift();
    const g=gen.get(u);
    for(const p of parents.get(u)){
      if(!gen.has(p)){ gen.set(p, g+1); q.push(p); }
    }
    for(const c of children.get(u)){
      if(!gen.has(c)){ gen.set(c, g-1); q.push(c); }
    }
  }
  // Fill still-unset nodes with neutral baseline first.
  PEOPLE.forEach(p=>{ if(!gen.has(p.id)) gen.set(p.id,0); });

  // Semantic normalization (compact mode):
  // - parents must stay above children
  // - spouses share one generation
  // - siblings in one family are collapsed to one generation (nearest compact level)
  // This avoids "row explosion" while preserving parent/child meaning.
  const MAX_RELAX_PASSES = 24;
  for(let pass=0; pass<MAX_RELAX_PASSES; pass++){
    let changed=false;

    FAMS.forEach(f=>{
      const ps=[...(f.husband||[]), ...(f.wife||[])].filter(id=>MAP[id]);
      const ch=(f.children||[]).filter(id=>MAP[id]);
      if(!ps.length || !ch.length) return;

      const maxChildGen = Math.max(...ch.map(id=>gen.get(id)));
      const minParentNeed = maxChildGen + 1;

      // Raise only under-elevated parents to keep parent->child direction strict.
      ps.forEach(id=>{
        if(gen.get(id) < minParentNeed){
          gen.set(id, minParentNeed);
          changed=true;
        }
      });

      // Spouses on same level.
      const parentGen = Math.max(...ps.map(id=>gen.get(id)));
      ps.forEach(id=>{
        if(gen.get(id) !== parentGen){
          gen.set(id, parentGen);
          changed=true;
        }
      });

      // Compact siblings: pull higher outliers down to the lowest sibling level,
      // but never above parentGen-1.
      const currentChildMin = Math.min(...ch.map(id=>gen.get(id)));
      const targetChildGen = Math.min(currentChildMin, parentGen - 1);
      ch.forEach(id=>{
        if(gen.get(id) > targetChildGen){
          gen.set(id, targetChildGen);
          changed=true;
        }
      });
    });

    if(!changed) break;
  }

  // Keep Ed at generation 0 after normalization.
  const rootGen = gen.get(ROOT_ID) || 0;
  if(rootGen !== 0){
    PEOPLE.forEach(p=>gen.set(p.id, gen.get(p.id) - rootGen));
  }

  // Convert: highest gen number = top row (level 0), Ed = bottom
  const maxGen=Math.max(...[...gen.values()]);
  const level=new Map();
  PEOPLE.forEach(p=>level.set(p.id, maxGen - gen.get(p.id)));

  const layers={};
  PEOPLE.forEach(p=>{const l=level.get(p.id); (layers[l]=layers[l]||[]).push(p.id);});
  Object.values(layers).forEach(arr=>arr.sort((a,b)=>
    (MAP[a].surname||'').localeCompare(MAP[b].surname||'','ru') ||
    (MAP[a].name||'').localeCompare(MAP[b].name||'','ru')
  ));

  // reorder for fewer crossings (top-down by parents + bottom-up by children)
  const levelKeys=Object.keys(layers).map(Number).sort((a,b)=>a-b);
  for(let pass=0; pass<6; pass++){
    // top-down (parent barycenter)
    for(const l of levelKeys){
      const arr=layers[l], prev=layers[l-1]||[];
      arr.sort((a,b)=>{
        const avg=(id)=>{
          const pars=[...parents.get(id)];
          if(!pars.length) return prev.length + 100;
          return pars.reduce((s,p)=>s + (prev.indexOf(p)>=0?prev.indexOf(p):prev.length+5),0)/pars.length;
        };
        return avg(a)-avg(b);
      });
    }

    // bottom-up (child barycenter)
    for(const l of [...levelKeys].reverse()){
      const arr=layers[l], next=layers[l+1]||[];
      arr.sort((a,b)=>{
        const avg=(id)=>{
          const ch=[...children.get(id)];
          if(!ch.length) return next.length + 100;
          return ch.reduce((s,c)=>s + (next.indexOf(c)>=0?next.indexOf(c):next.length+5),0)/ch.length;
        };
        return avg(a)-avg(b);
      });
    }
  }

  const margin=24;
  const maxCols=Math.max(...Object.values(layers).map(a=>a.length));
  const depth=Math.max(...levelKeys);

  // compress base geometry so full tree stays readable on one screen more often
  const targetW=1500, targetH=920;
  const gx = maxCols > 9 ? 12 : 16;
  const gy = 120; // Increased gap to allow clear routing channels

  const nodeW = Math.max(104, Math.min(170,
    Math.floor((targetW - 2*margin - Math.max(0,maxCols-1)*gx) / maxCols)
  ));
  const nodeH = Math.max(46, Math.min(58,
    Math.floor((targetH - 2*margin - Math.max(0,depth)*gy) / (depth+1))
  ));

  const worldW = Math.max(900, margin*2 + maxCols*nodeW + Math.max(0,maxCols-1)*gx);
  const worldH = Math.max(620, margin*2 + (depth+1)*nodeH + Math.max(0,depth)*gy);

  const xy={};
  const minLevel = Math.min(...levelKeys);
  const step = nodeW + gx;

  for(const l of levelKeys){
    const arr=layers[l];
    const rowW=arr.length*nodeW + Math.max(0,arr.length-1)*gx;
    const y=margin + l*(nodeH+gy);

    let baseX = (worldW-rowW)/2;

    // Shift row toward parent barycenter so children sit under their parents.
    if(l !== minLevel){
      const candidates=[];
      arr.forEach((id,idx)=>{
        const pars=[...parents.get(id)].filter(pid=>xy[pid]);
        if(!pars.length) return;
        const parentCenter = pars.reduce((s,pid)=>s + (xy[pid].x + nodeW/2), 0) / pars.length;
        const offset = parentCenter - (idx*step + nodeW/2);
        candidates.push(offset);
      });
      if(candidates.length){
        baseX = candidates.reduce((s,v)=>s+v,0)/candidates.length;
      }
    }

    const minX=margin;
    const maxX=Math.max(minX, worldW - rowW - margin);
    baseX=Math.max(minX, Math.min(maxX, baseX));

    let x=baseX;
    arr.forEach(id=>{xy[id]={x,y}; x+=step;});
  }

  graph={xy,nodeW,nodeH,worldW,worldH};
}

function applyViewBox(){
  svg.setAttribute('viewBox',`${view.x} ${view.y} ${view.w} ${view.h}`);
}

function fitView(){
  if(!graph) return;
  view={x:0,y:0,w:graph.worldW,h:graph.worldH};
  applyViewBox();
}

function clampView(){
  if(!graph) return;
  view.w=Math.max(graph.worldW*0.12, Math.min(graph.worldW, view.w));
  view.h=Math.max(graph.worldH*0.12, Math.min(graph.worldH, view.h));
  view.x=Math.max(0, Math.min(graph.worldW-view.w, view.x));
  view.y=Math.max(0, Math.min(graph.worldH-view.h, view.y));
}

function zoom(factor){
  if(!graph) return;
  const cx=view.x+view.w/2, cy=view.y+view.h/2;
  view.w*=factor; view.h*=factor;
  clampView();
  view.x=cx-view.w/2; view.y=cy-view.h/2;
  clampView();
  applyViewBox();
}

function centerOnSelected(){
  if(!graph || !selected || !graph.xy[selected]) return;
  const c=graph.xy[selected];
  const cx=c.x+graph.nodeW/2, cy=c.y+graph.nodeH/2;
  view.x=cx-view.w/2; view.y=cy-view.h/2;
  clampView();
  applyViewBox();
}

function drawGraph(){
  if(!graph) return;
  svg.innerHTML='';

  const {xy,nodeW,nodeH}=graph;

  // Layers: edges first, nodes on top. Edges are routed around cards,
  // and nodes remain visually clean/readable.
  const edgeLayer=document.createElementNS('http://www.w3.org/2000/svg','g');
  edgeLayer.setAttribute('data-layer','edges');
  edgeLayer.setAttribute('pointer-events','none');

  // === FAMILY COLOR PALETTE ===
  const FAMILY_COLORS = [
    '#6ec6ff', '#f7a072', '#a78bfa', '#4ade80', '#f472b6',
    '#fbbf24', '#67e8f9', '#c084fc', '#fb923c', '#86efac',
    '#f87171', '#38bdf8', '#a3e635', '#e879f9', '#fcd34d',
    '#5eead4', '#fb7185',
  ];

  // Build occupancy grid: for each level, list of {left,right} rectangles
  const occupancy = {};
  PEOPLE.forEach(p=>{
    const pos=xy[p.id]; if(!pos) return;
    const l = Math.round(pos.y); // approx level y
    if(!occupancy[l]) occupancy[l]=[];
    occupancy[l].push({left:pos.x, right:pos.x+nodeW, id:p.id});
  });

  // Build level Y ranges (nodeTop→nodeBottom) for collision detection
  const levelYRanges = {};
  PEOPLE.forEach(p=>{
    const pos=xy[p.id]; if(!pos) return;
    const ly = pos.y;
    if(!levelYRanges[ly]) levelYRanges[ly]={top:ly, bottom:ly+nodeH, nodes:[]};
    levelYRanges[ly].nodes.push({left:pos.x, right:pos.x+nodeW, id:p.id});
  });

  // Node rectangles for obstacle avoidance (exclude current family members when routing their own links).
  const nodeRects = PEOPLE.map(p=>{
    const pos=xy[p.id];
    if(!pos) return null;
    return {id:p.id, left:pos.x, right:pos.x+nodeW, top:pos.y, bottom:pos.y+nodeH};
  }).filter(Boolean);

  function verticalHitsNode(x, y1, y2, famMembers){
    const a=Math.min(y1,y2), b=Math.max(y1,y2);
    const pad=3;
    return nodeRects.some(n=>{
      if(famMembers?.has(n.id)) return false;
      const xHit = x > (n.left-pad) && x < (n.right+pad);
      const yHit = a < (n.bottom+pad) && b > (n.top-pad);
      return xHit && yHit;
    });
  }

  function horizontalHitsNode(y, x1, x2, famMembers){
    const a=Math.min(x1,x2), b=Math.max(x1,x2);
    const pad=3;
    return nodeRects.some(n=>{
      if(famMembers?.has(n.id)) return false;
      const yHit = y > (n.top-pad) && y < (n.bottom+pad);
      const xHit = a < (n.right+pad) && b > (n.left-pad);
      return xHit && yHit;
    });
  }

  // Find a clear vertical X channel that avoids nodes for the whole segment.
  function findClearChannel(fromY, toY, preferX, famMembers){
    if(!verticalHitsNode(preferX, fromY, toY, null)) return preferX;
    for(let d=8; d<graph.worldW; d+=6){
      const xl = preferX - d;
      if(xl > 4 && !verticalHitsNode(xl, fromY, toY, null)) return xl;
      const xr = preferX + d;
      if(xr < graph.worldW-4 && !verticalHitsNode(xr, fromY, toY, null)) return xr;
    }
    return preferX;
  }

  const INTO = 6;

  // === GLOBAL LANE REGISTRY: avoid overlaps/crossings between routed segments ===
  const usedYLanes = []; // [{y, x1, x2}] horizontal segments
  const usedXLanes = []; // [{x, y1, y2}] vertical segments

  function reserveYLane(y, x1, x2){
    usedYLanes.push({y, x1: Math.min(x1,x2), x2: Math.max(x1,x2)});
  }
  function reserveXLane(x, y1, y2){
    usedXLanes.push({x, y1: Math.min(y1,y2), y2: Math.max(y1,y2)});
  }

  function crossesVerticalLane(y, x1, x2){
    const a=Math.min(x1,x2), b=Math.max(x1,x2);
    const eps=0.2; // allow endpoint touching
    return usedXLanes.some(v => (v.x > a+eps && v.x < b-eps) && (y > v.y1+eps && y < v.y2-eps));
  }

  function crossesHorizontalLane(x, y1, y2){
    const a=Math.min(y1,y2), b=Math.max(y1,y2);
    const eps=0.2;
    return usedYLanes.some(h => (h.y > a+eps && h.y < b-eps) && (x > h.x1+eps && x < h.x2-eps));
  }

  function isYLaneFree(y, x1, x2, famMembers){
    const a=Math.min(x1,x2), b=Math.max(x1,x2);
    // Strict avoidance of parallel overlap (other horizontal lines on same Y)
    const lineFree = !usedYLanes.some(l => Math.abs(l.y - y) < 6 && l.x1 < b && a < l.x2);
    if(!lineFree) return false;
    
    // Allow orthogonal crossings (vertical lines cutting through this horizontal),
    // because blocking them makes routing impossible in dense graphs.
    // We only strictly block cutting through CARDS.
    return !horizontalHitsNode(y, a, b, null);
  }

  function findFreeYLane(preferY, x1, x2, minY, maxY, famMembers){
    const baseMin=Math.min(minY,maxY), baseMax=Math.max(minY,maxY);
    const hardMin=Math.max(2, baseMin - (nodeH + 22));
    const hardMax=Math.min(graph.worldH-2, baseMax + (nodeH + 22));

    // Try preferred Y first
    const start=Math.max(hardMin, Math.min(hardMax, preferY));
    if(isYLaneFree(start, x1, x2, famMembers)) return start;

    // Search outwards with wider step to prevent "stripe" clusters
    const step = 8; 
    for(let d=step; d < (hardMax-hardMin)+60; d+=step){
      const yUp = start - d;
      if(yUp >= hardMin && isYLaneFree(yUp, x1, x2, famMembers)) return yUp;
      const yDown = start + d;
      if(yDown <= hardMax && isYLaneFree(yDown, x1, x2, famMembers)) return yDown;
    }
    return start;
  }

  function isXLaneFree(x, y1, y2, famMembers){
    const a=Math.min(y1,y2), b=Math.max(y1,y2);
    // Strict avoidance of parallel overlap (other vertical lines on same X)
    const lineFree = !usedXLanes.some(l => Math.abs(l.x - x) < 6 && l.y1 < b && a < l.y2);
    if(!lineFree) return false;

    // Allow orthogonal crossings (horizontal lines cutting through this vertical)
    return !verticalHitsNode(x, a, b, null);
  }

  function findFreeXLane(preferX, y1, y2, famMembers){
    if(isXLaneFree(preferX, y1, y2, famMembers)) return preferX;
    for(let d=5; d < graph.worldW; d+=5){
      const xl = preferX - d;
      if(xl > 4 && isXLaneFree(xl, y1, y2, famMembers)) return xl;
      const xr = preferX + d;
      if(xr < graph.worldW-4 && isXLaneFree(xr, y1, y2, famMembers)) return xr;
    }
    return preferX;
  }

  // === ANCHOR OFFSET: when a person appears in multiple families, offset attachment points ===
  const anchorUsage = {};
  FAMS.forEach((f, fi)=>{
    const ps=[...(f.husband||[]), ...(f.wife||[])].filter(id=>xy[id]);
    const ch=(f.children||[]).filter(id=>xy[id]);
    if(!ps.length || !ch.length) return;
    ps.forEach(id=>{
      if(!anchorUsage[id]) anchorUsage[id]={asParent:[],asChild:[]};
      anchorUsage[id].asParent.push(fi);
    });
    ch.forEach(id=>{
      if(!anchorUsage[id]) anchorUsage[id]={asParent:[],asChild:[]};
      anchorUsage[id].asChild.push(fi);
    });
  });

  function getAnchorXOffset(personId, role, fi){
    const u = anchorUsage[personId];
    if(!u) return 0;
    const allFams = [...new Set([...u.asParent, ...u.asChild])];
    if(allFams.length <= 1) return 0;
    const idx = allFams.indexOf(fi);
    const total = allFams.length;
    const spread = Math.min(nodeW * 0.4, total * 10);
    return (idx - (total-1)/2) * (spread / Math.max(1, total-1));
  }

  FAMS.forEach((f, fi)=>{
    const ps=[...(f.husband||[]), ...(f.wife||[])].filter(id=>xy[id]);
    const ch=(f.children||[]).filter(id=>xy[id]);
    if(!ps.length || !ch.length) return;

    const color = FAMILY_COLORS[fi % FAMILY_COLORS.length];
    const famMembers = new Set([...ps, ...ch]);

    const famG=document.createElementNS('http://www.w3.org/2000/svg','g');
    famG.setAttribute('stroke', color);
    famG.setAttribute('fill','none');
    famG.setAttribute('stroke-width','1.8');
    famG.setAttribute('stroke-linecap','round');
    famG.setAttribute('stroke-linejoin','round');
    famG.setAttribute('shape-rendering','geometricPrecision');

    const parentAnchors=ps.map(id=>({
      id,
      x:xy[id].x+nodeW/2+getAnchorXOffset(id,'parent',fi),
      yTop:xy[id].y,
      yBottom:xy[id].y+nodeH,
    }));
    const childAnchors=ch.map(id=>({
      id,
      x:xy[id].x+nodeW/2+getAnchorXOffset(id,'child',fi),
      yTop:xy[id].y,
      yBottom:xy[id].y+nodeH,
    }));

    const parentBottomEdge = Math.max(...ps.map(id=>xy[id].y+nodeH));
    const childTopEdge = Math.min(...ch.map(id=>xy[id].y));

    const hubX = (Math.min(...parentAnchors.map(a=>a.x)) + Math.max(...parentAnchors.map(a=>a.x))) / 2;

    // Estimate full X extents that bars will span (parents + hub + children)
    const allBarX = [...parentAnchors.map(a=>a.x), ...childAnchors.map(a=>a.x), hubX];
    const fullBarLeft = Math.min(...allBarX) - 10;
    const fullBarRight = Math.max(...allBarX) + 10;

    // Handle split-level families (where parents and children overlap in Y)
    // Use the actual vertical space available between parent anchors and child anchors
    const parentAnchorBottom = Math.max(...parentAnchors.map(a=>a.yBottom));
    const childAnchorTop = Math.min(...childAnchors.map(a=>a.yTop));
    const effectiveGapTop = Math.min(parentAnchorBottom, childAnchorTop);
    const effectiveGapBottom = Math.max(parentAnchorBottom, childAnchorTop);
    const gapMidpoint = (effectiveGapTop + effectiveGapBottom) / 2;
    
    // Find free Y lanes using the FULL bar extent so no cross-family overlap
    const preferYMid = effectiveGapTop + Math.min(14, (effectiveGapBottom - effectiveGapTop) * 0.3);
    const preferYChild = effectiveGapBottom - Math.min(14, (effectiveGapBottom - effectiveGapTop) * 0.3);
    
    const yMid = findFreeYLane(preferYMid, fullBarLeft, fullBarRight, effectiveGapTop, effectiveGapBottom, famMembers);
    const yChildBar = findFreeYLane(preferYChild, fullBarLeft, fullBarRight, effectiveGapTop, effectiveGapBottom, famMembers);

    // Detect multi-level gap: if there are intermediate levels with nodes between parents and children
    const multiLevel = (effectiveGapBottom - effectiveGapTop) > (nodeH + 40);

    // === PARENT SIDE ===
    parentAnchors.forEach(a=>{
      // Exit the card from the side closer to the selected lane.
      // But actually, we ALWAYS want to exit 'bottom' for parents typically.
      const startY = a.yBottom; 
      
      // We want to go to yMid.
      // STRATEGY: 
      // 1. Go down vertically from a.x for a "Clearance" distance.
      // 2. Jog horizontally to ax.
      // 3. Continue vertically at ax to yMid.
      
      let clearance = 10;
      if(yMid < startY) clearance = -10; 
      if(Math.abs(yMid - startY) < Math.abs(clearance)) clearance = yMid - startY;
      
      const initialJogY = startY + clearance;
      
      // 2. Find clean horizontal lane for the jog
      // Search range: slightly above/below initial guess
      const safeJogY = findFreeYLane(initialJogY, a.x, ax, startY-30, startY+30, famMembers);

      // Find safe vertical for the main drop from safeJogY to yMid
      const ax = findFreeXLane(a.x, safeJogY, yMid, famMembers);

      // 1. Vertical stub out of card
      if(Math.abs(safeJogY - startY) > 0.1){
        const stub = document.createElementNS('http://www.w3.org/2000/svg','line');
        stub.setAttribute('x1', a.x); stub.setAttribute('y1', startY);
        stub.setAttribute('x2', a.x); stub.setAttribute('y2', safeJogY);
        famG.appendChild(stub);
        reserveXLane(a.x, startY, safeJogY);
      }

      // 2. Horizontal jog
      if(Math.abs(ax - a.x) > 0.2){
        const jog=document.createElementNS('http://www.w3.org/2000/svg','line');
        jog.setAttribute('x1',a.x); jog.setAttribute('y1',safeJogY);
        jog.setAttribute('x2',ax);  jog.setAttribute('y2',safeJogY);
        famG.appendChild(jog);
        reserveYLane(safeJogY, a.x, ax);
      }

      // 3. Main vertical drop
      if(Math.abs(yMid - safeJogY) > 0.1){
        const line=document.createElementNS('http://www.w3.org/2000/svg','line');
        line.setAttribute('x1',ax); line.setAttribute('y1',safeJogY);
        line.setAttribute('x2',ax); line.setAttribute('y2',yMid);
        famG.appendChild(line);
        reserveXLane(ax, safeJogY, yMid);
      }
      
      a._ax = ax; // store adjusted X for bar
    });
    if(parentAnchors.length>1){
      const h=document.createElementNS('http://www.w3.org/2000/svg','line');
      const pxs = parentAnchors.map(a=>a._ax||a.x);
      const pLeft=Math.min(...pxs), pRight=Math.max(...pxs);
      h.setAttribute('x1', pLeft);
      h.setAttribute('x2', pRight);
      h.setAttribute('y1', yMid); h.setAttribute('y2', yMid);
      famG.appendChild(h);
      reserveYLane(yMid, pLeft, pRight);
    }

    // Marriage dot
    const dot=document.createElementNS('http://www.w3.org/2000/svg','circle');
    dot.setAttribute('cx',hubX); dot.setAttribute('cy',yMid);
    dot.setAttribute('r','3'); dot.setAttribute('fill',color);
    famG.appendChild(dot);

    // === HUB → CHILDREN with obstacle avoidance ===
    let hubEndX = hubX;
    if(multiLevel){
      const channelX = findClearChannel(yMid, yChildBar, hubX, famMembers);
      const freeChX = findFreeXLane(channelX, yMid, yChildBar, famMembers);
      hubEndX = freeChX;

      const path=document.createElementNS('http://www.w3.org/2000/svg','polyline');
      const pts = [
        `${hubX},${yMid}`,
        `${freeChX},${yMid}`,
        `${freeChX},${yChildBar}`,
      ];
      path.setAttribute('points', pts.join(' '));
      famG.appendChild(path);
      if(Math.abs(freeChX - hubX) > 0.2) reserveYLane(yMid, hubX, freeChX);
      reserveXLane(freeChX, yMid, yChildBar);
    } else {
      // Direct: hub → childBar
      const freeHubX = findFreeXLane(hubX, yMid, yChildBar, famMembers);
      hubEndX = freeHubX;
      const vDown=document.createElementNS('http://www.w3.org/2000/svg','line');
      vDown.setAttribute('x1',freeHubX); vDown.setAttribute('y1',yMid);
      vDown.setAttribute('x2',freeHubX); vDown.setAttribute('y2',yChildBar);
      famG.appendChild(vDown);
      reserveXLane(freeHubX, yMid, yChildBar);
    }

    // Horizontal bar across children + connect to routing
    const allX = childAnchors.map(a=>a.x);
    allX.push(hubEndX);
    const barLeft = Math.min(...allX);
    const barRight = Math.max(...allX);
    if(barLeft !== barRight){
      const hBar=document.createElementNS('http://www.w3.org/2000/svg','line');
      hBar.setAttribute('x1', barLeft); hBar.setAttribute('x2', barRight);
      hBar.setAttribute('y1', yChildBar); hBar.setAttribute('y2', yChildBar);
      famG.appendChild(hBar);
      reserveYLane(yChildBar, barLeft, barRight);
    }

    // Each child: vertical from bar into node.
    childAnchors.forEach(a=>{
      const endY = a.yTop; 
      
      let clearance = -10; 
      if(yChildBar > endY) clearance = 10;
      if(Math.abs(yChildBar - endY) < Math.abs(clearance)) clearance = yChildBar - endY;
      
      const initialJogY = endY + clearance;
      
      // Find a clean Y-lane for the jog
      const safeJogY = findFreeYLane(initialJogY, a.x, ax, endY-30, endY+30, famMembers);

      // Find safe lane for main drop from yChildBar to safeJogY
      const ax = findFreeXLane(a.x, yChildBar, safeJogY, famMembers);

      // 1. Main vertical drop from bar
      if(Math.abs(safeJogY - yChildBar) > 0.1){
        const line=document.createElementNS('http://www.w3.org/2000/svg','line');
        line.setAttribute('x1',ax); line.setAttribute('y1',yChildBar);
        line.setAttribute('x2',ax); line.setAttribute('y2',safeJogY);
        famG.appendChild(line);
        reserveXLane(ax, yChildBar, safeJogY);
      }

      // 2. Horizontal jog
      if(Math.abs(ax - a.x) > 0.2){
        const jog=document.createElementNS('http://www.w3.org/2000/svg','line');
        jog.setAttribute('x1',ax);  jog.setAttribute('y1',safeJogY);
        jog.setAttribute('x2',a.x); jog.setAttribute('y2',safeJogY);
        famG.appendChild(jog);
        reserveYLane(safeJogY, ax, a.x);
      }

      // 3. Vertical stub into card
      if(Math.abs(endY - safeJogY) > 0.1){
        const stub = document.createElementNS('http://www.w3.org/2000/svg','line');
        stub.setAttribute('x1', a.x); stub.setAttribute('y1', safeJogY);
        stub.setAttribute('x2', a.x); stub.setAttribute('y2', endY);
        famG.appendChild(stub);
        reserveXLane(a.x, safeJogY, endY);
      }
    });

    edgeLayer.appendChild(famG);
  });

  const nodes=document.createElementNS('http://www.w3.org/2000/svg','g');
  PEOPLE.forEach(p=>{
    const pos=xy[p.id]; if(!pos) return;
    const g=document.createElementNS('http://www.w3.org/2000/svg','g');
    g.classList.add('node'); g.dataset.id=p.id;

    const isKey=['I1','I7','I16','I17'].includes(p.id);
    const isMention=['I135','I263','I265','I268'].includes(p.id);

    let fill='var(--node)', stroke='var(--node-stroke)';
    if(isKey){ fill='var(--node-key)'; stroke='var(--node-key-stroke)'; }
    else if(isMention){ fill='var(--node-mention)'; stroke='var(--node-mention-stroke)'; }
    else if((p.sex||'').toUpperCase()==='M'){ fill='var(--male)'; stroke='var(--male-stroke)'; }
    else if((p.sex||'').toUpperCase()==='F'){ fill='var(--female)'; stroke='var(--female-stroke)'; }

    const rect=document.createElementNS('http://www.w3.org/2000/svg','rect');
    rect.setAttribute('x',pos.x); rect.setAttribute('y',pos.y);
    rect.setAttribute('width',nodeW); rect.setAttribute('height',nodeH);
    rect.setAttribute('fill',fill); rect.setAttribute('stroke',stroke);

    const [rawLine1, rawLine2] = splitName2(p.name||p.name_raw,p.id, Math.max(12, Math.floor((nodeW-16)/7.6)));
    const yy=years(p);

    // Keep years from colliding with the second name line on compact nodes.
    const nameY1 = pos.y + (nodeH<52 ? 16 : 18);
    const lineGap = nodeW<120 ? 12 : 13;
    const nameY2 = nameY1 + lineGap;
    const yearsY = pos.y + nodeH - 7;
    const showLine2 = !!rawLine2 && ((yearsY - nameY2) >= 11);

    const line1 = rawLine1;
    const line2 = showLine2 ? rawLine2 : '';

    const t1=document.createElementNS('http://www.w3.org/2000/svg','text');
    t1.setAttribute('x',pos.x+8); t1.setAttribute('y',nameY1);
    t1.setAttribute('font-size', nodeW<120 ? '10.0' : '11.3');
    t1.setAttribute('fill','#121a27');
    t1.textContent=line1;

    const t1b=document.createElementNS('http://www.w3.org/2000/svg','text');
    t1b.setAttribute('x',pos.x+8); t1b.setAttribute('y',nameY2);
    t1b.setAttribute('font-size', nodeW<120 ? '10.0' : '11.3');
    t1b.setAttribute('fill','#121a27');
    t1b.textContent=line2;

    const t2=document.createElementNS('http://www.w3.org/2000/svg','text');
    t2.setAttribute('x',pos.x+nodeW-8); t2.setAttribute('y',yearsY);
    t2.setAttribute('text-anchor','end');
    t2.setAttribute('font-size', nodeW<120 ? '9.2' : '10.2');
    t2.setAttribute('fill','#314764');
    t2.textContent=yy || '';

    const title=document.createElementNS('http://www.w3.org/2000/svg','title');
    title.textContent=`${(p.name||p.name_raw||p.id).replaceAll('/','').trim()}${yy?(' · '+yy):''}`;

    g.appendChild(rect); g.appendChild(t1); g.appendChild(t1b); g.appendChild(t2); g.appendChild(title);
    g.onclick=()=>select(p.id,true);
    nodes.appendChild(g);
  });

  svg.appendChild(edgeLayer);
  svg.appendChild(nodes);
  applyViewBox();
  highlightSelected();
}

function highlightSelected(){
  svg.querySelectorAll('.node rect').forEach(r=>r.setAttribute('stroke-width','1.4'));
  if(!selected) return;
  const n=svg.querySelector(`.node[data-id='${selected}'] rect`);
  if(n){ n.setAttribute('stroke','#ef4444'); n.setAttribute('stroke-width','3'); }
}

function select(id,center=false){
  selected=id;
  renderDetails(id);
  renderList(PEOPLE);
  highlightSelected();
  if(center) centerOnSelected();
}

function bindGraphInteractions(){
  let dragging=false, start=null, startView=null;

  svg.addEventListener('mousedown',(e)=>{
    if(e.button!==0) return;
    dragging=true;
    start={x:e.clientX,y:e.clientY};
    startView={...view};
  });

  window.addEventListener('mousemove',(e)=>{
    if(!dragging) return;
    const dxPx=e.clientX-start.x;
    const dyPx=e.clientY-start.y;
    const scaleX=startView.w/host.clientWidth;
    const scaleY=startView.h/host.clientHeight;
    view.x=startView.x - dxPx*scaleX;
    view.y=startView.y - dyPx*scaleY;
    clampView();
    applyViewBox();
  });

  window.addEventListener('mouseup',()=>{ dragging=false; });

  // Deterministic trackpad behavior:
  // - 2-finger scroll = PAN
  // - zoom only on explicit Ctrl+wheel/pinch signal
  // This avoids random mode switching on noisy gesture streams.
  function normalizeWheelDelta(e){
    let dx=e.deltaX, dy=e.deltaY;
    if(e.deltaMode===1){ // lines
      dx*=16; dy*=16;
    } else if(e.deltaMode===2){ // pages
      dx*=host.clientWidth;
      dy*=host.clientHeight;
    }
    return {dx,dy};
  }

  let wheelMode='pan';
  let wheelModeUntil=0;
  let pendingPanX=0, pendingPanY=0, panRaf=0;

  function flushPan(){
    panRaf=0;
    if(!pendingPanX && !pendingPanY) return;
    view.x += pendingPanX;
    view.y += pendingPanY;
    pendingPanX=0; pendingPanY=0;
    clampView();
    applyViewBox();
  }

  host.addEventListener('wheel',(e)=>{
    e.preventDefault();
    e.stopPropagation();

    const now=performance.now();
    const {dx,dy}=normalizeWheelDelta(e);
    if(Math.abs(dx)<0.01 && Math.abs(dy)<0.01) return;

    const wantsZoom = !!e.ctrlKey; // keep strict: Ctrl/pinch only

    // Lock interaction mode for a short burst to prevent flicker pan<->zoom.
    if(now > wheelModeUntil){
      wheelMode = wantsZoom ? 'zoom' : 'pan';
    } else if(wheelMode==='zoom' && !wantsZoom){
      // Keep zoom mode until burst ends.
    } else if(wheelMode==='pan' && wantsZoom){
      // Only switch to zoom in-burst for clearly zoom-like movement.
      if(Math.abs(dy) > Math.abs(dx)*1.25) wheelMode='zoom';
    }
    wheelModeUntil = now + (wheelMode==='zoom' ? 180 : 120);

    if(wheelMode==='zoom'){
      const strength=Math.min(1.7, Math.max(0.6, Math.abs(dy)/140));
      const factor = dy<0 ? (1 - 0.14*strength) : (1 + 0.14*strength);
      zoom(Math.max(0.78, Math.min(1.24, factor)));
      return;
    }

    // Pan path (scheduled on RAF to avoid choppy delayed response).
    const panBoost=1.45;
    const scaleX=(view.w/host.clientWidth)*panBoost;
    const scaleY=(view.h/host.clientHeight)*panBoost;
    pendingPanX += dx * scaleX;
    pendingPanY += dy * scaleY;
    if(!panRaf) panRaf=requestAnimationFrame(flushPan);
  }, {passive:false});

  fitBtn.onclick=()=>fitView();
  zoomInBtn.onclick=()=>zoom(0.88);
  zoomOutBtn.onclick=()=>zoom(1.14);
  centerBtn.onclick=()=>centerOnSelected();

  window.addEventListener('resize',()=>{
    // keep same center while resizing
    const cx=view.x+view.w/2, cy=view.y+view.h/2;
    drawGraph();
    view.x=cx-view.w/2; view.y=cy-view.h/2;
    clampView();
    applyViewBox();
    renderVersionInfo();
  });
}

async function init(){
  const r=await fetch('data.json');
  DATA=await r.json();
  PEOPLE=DATA.people;
  FAMS=DATA.families;
  MAP=Object.fromEntries(PEOPLE.map(p=>[p.id,p]));

  elMeta.textContent=`Людей: ${DATA.meta.people_count} · Семей: ${DATA.meta.families_count} · ${DATA.meta.generator}`;
  renderVersionInfo();
  setInterval(renderVersionInfo, 60000);

  renderList(PEOPLE);
  buildGraphModel();
  fitView();
  drawGraph();
  bindGraphInteractions();

  const start = MAP['I1'] ? 'I1' : PEOPLE[0]?.id;
  if(start) select(start,true);

  elQ.oninput=()=>{
    const q=elQ.value.trim().toLowerCase();
    const arr=!q ? PEOPLE : PEOPLE.filter(p=>`${p.id} ${p.name} ${p.name_raw} ${p.surname} ${p.given}`.toLowerCase().includes(q));
    renderList(arr);
  };
}

init().catch(err=>{
  console.error(err);
  elMeta.textContent='Ошибка загрузки data.json';
});
</script>
</body>
</html>
