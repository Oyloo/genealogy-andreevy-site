<!doctype html>
<html lang="ru">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Генеалогия — custom</title>
<style>
:root{
  --bg:#0b1220; --panel:#111a2b; --line:#24324d; --txt:#e8eef9; --muted:#9fb0cc;
  --graph-bg:#0a1324; --edge:#87a4d4;
  --node:#b8a8ff; --node-stroke:#8f74ff;
  --male:#9cc8ff; --male-stroke:#3b82f6;
  --female:#f8b4d8; --female-stroke:#db2777;
  --node-key:#93c5fd; --node-key-stroke:#2563eb;
  --node-mention:#fdba74; --node-mention-stroke:#ea580c;
}
*{box-sizing:border-box}
html,body{height:100%}
body{margin:0;font-family:Inter,Segoe UI,Arial,sans-serif;background:linear-gradient(180deg,#0b1220,#0f1728);color:var(--txt)}
header{padding:14px 16px;border-bottom:1px solid var(--line);background:#0b1220eb;backdrop-filter:blur(6px);position:sticky;top:0;z-index:20}
h1{margin:0;font-size:18px}
.meta{margin-top:6px;font-size:12px;color:var(--muted)}
.layout{display:grid;grid-template-columns:280px 1fr 370px;gap:10px;padding:10px;height:calc(100vh - 68px)}
.panel{border:1px solid var(--line);background:var(--panel);border-radius:12px;overflow:hidden;min-height:0;display:flex;flex-direction:column}
.panel h2{margin:0;padding:9px 12px;border-bottom:1px solid var(--line);font-size:13px;color:#c6d6f2;display:flex;justify-content:space-between;align-items:center;gap:8px}
.content{padding:10px;overflow:auto;min-height:0;flex:1}
input{width:100%;padding:9px 10px;border-radius:9px;border:1px solid #294063;background:#0c1628;color:#e8eef9}
.item{margin-top:6px;border:1px solid #253754;background:#0d1728;padding:8px;border-radius:9px;cursor:pointer}
.item.active{border-color:#67b0ff;background:#10203a}
.small{font-size:12px;color:var(--muted)}

/* visible scrollbars */
.content::-webkit-scrollbar{width:10px;height:10px}
.content::-webkit-scrollbar-track{background:#0b1527;border-radius:8px}
.content::-webkit-scrollbar-thumb{background:#35507a;border-radius:8px}
.content::-webkit-scrollbar-thumb:hover{background:#4a6ea8}

#graphHost{position:relative;height:100%;background:var(--graph-bg);border-radius:8px;border:1px solid #253b5f;overflow:hidden;overscroll-behavior:none}
#graphSvg{position:absolute;inset:0;width:100%;height:100%;user-select:none}
.legend{display:flex;gap:10px;align-items:center;flex-wrap:wrap}
.legend span{display:inline-flex;align-items:center;gap:5px;font-size:11px;color:#cbd8ef}
.dot{width:10px;height:10px;border-radius:50%}
.ctrls{display:flex;gap:6px;align-items:center;flex-wrap:wrap}
.btn{font-size:12px;padding:4px 8px;border-radius:8px;border:1px solid #3b4c6a;background:#101a2d;color:#d9e7ff;cursor:pointer}
.btn:hover{border-color:#67b0ff;color:#fff}
.hint{position:absolute;left:8px;bottom:8px;background:#0b1220cf;color:#d9e7ff;font-size:11px;padding:4px 7px;border-radius:6px;pointer-events:none}

svg text{font-family:Arial,sans-serif}
.node rect{rx:10;ry:10;stroke-width:1.4;cursor:pointer}
.node:hover rect{stroke-width:2.2}

.row{margin:8px 0}
.k{font-size:11px;color:#9cb1d6;text-transform:uppercase;letter-spacing:.04em}
.v{margin-top:3px;white-space:pre-wrap;word-break:break-word}
a{color:#8ec7ff}
pre{white-space:pre-wrap;background:#0b1423;border:1px solid #24324d;border-radius:8px;padding:8px;font-size:12px;line-height:1.35;max-height:380px;overflow:auto}
details summary{cursor:pointer;color:#b9cef4;font-size:12px}

@media(max-width:1300px){.layout{grid-template-columns:250px 1fr 330px}}
@media(max-width:1100px){.layout{grid-template-columns:1fr;height:auto}.panel{height:64vh}}
</style>
</head>
<body>
<header>
  <h1>Генеалогия (custom renderer с нуля, без Graphviz)</h1>
  <div class="meta" id="meta">Загрузка...</div>
  <div class="meta" id="version" style="margin-top:4px;opacity:.88"></div>
</header>

<div class="layout">
  <section class="panel">
    <h2><span>Люди</span><span class="small" id="listCount"></span></h2>
    <div class="content">
      <input id="q" placeholder="Поиск: имя / фамилия / ID" />
      <div id="list"></div>
    </div>
  </section>

  <section class="panel">
    <h2>
      <span>Связи</span>
      <div class="ctrls">
        <button class="btn" id="fitBtn">Fit</button>
        <button class="btn" id="zoomInBtn">+</button>
        <button class="btn" id="zoomOutBtn">−</button>
        <button class="btn" id="centerBtn">Center selected</button>
      </div>
    </h2>
    <div class="content" style="padding:8px;display:flex;flex-direction:column;gap:8px;overflow:hidden">
      <div class="legend" id="legend">
        <span><i class="dot" style="background:var(--node-key)"></i> Эд + мама + её родители</span>
        <span><i class="dot" style="background:var(--node-mention)"></i> Минадора/Фоманида/Фомаида/Федора</span>
        <span><i class="dot" style="background:var(--female)"></i> Женщины</span>
        <span><i class="dot" style="background:var(--male)"></i> Мужчины</span>
        <span style="margin-left:12px;opacity:.7">Линии окрашены по семьям</span>
      </div>
      <div id="graphHost">
        <svg id="graphSvg"></svg>
        <div class="hint">ЛКМ drag — pan · 2 пальца на трекпаде — pan · pinch или Cmd/Ctrl+колесо — zoom</div>
      </div>
    </div>
  </section>

  <section class="panel">
    <h2>Карточка + все поля</h2>
    <div class="content" id="details">Выбери человека</div>
  </section>
</div>

<script>
let DATA, MAP={}, PEOPLE=[], FAMS=[], selected=null;
let graph=null; // {xy,nodeW,nodeH,worldW,worldH}
let view={x:0,y:0,w:100,h:100};

// Manual build marker: updates on each publish commit.
const APP_VERSION='20260224_1800';
const APP_BUILT_AT='2026-02-24 18:00 Europe/Riga';

const elMeta=document.getElementById('meta');
const elVersion=document.getElementById('version');
const elList=document.getElementById('list');
const elQ=document.getElementById('q');
const elDetails=document.getElementById('details');
const elCount=document.getElementById('listCount');
const host=document.getElementById('graphHost');
const svg=document.getElementById('graphSvg');

const fitBtn=document.getElementById('fitBtn');
const zoomInBtn=document.getElementById('zoomInBtn');
const zoomOutBtn=document.getElementById('zoomOutBtn');
const centerBtn=document.getElementById('centerBtn');

const esc=s=>(s??'').toString().replace(/[&<>\"]/g,c=>({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;'}[c]));

function renderVersionInfo(){
  const cb = new URLSearchParams(location.search).get('cache_bust');
  elVersion.textContent = `Версия: ${APP_VERSION} · Обновлён: ${APP_BUILT_AT}${cb?` · cache_bust=${cb}`:''}`;

  // Optional server timestamp to see what CDN served right now.
  fetch(window.location.href, { method:'HEAD', cache:'no-store' })
    .then(r=>{
      const lm=r.headers.get('last-modified');
      if(!lm) return;
      const d=new Date(lm);
      const lmText = Number.isNaN(d.getTime()) ? lm : d.toLocaleString('ru-RU', { hour12:false });
      elVersion.textContent += ` · Сервер: ${lmText}`;
    })
    .catch(()=>{});
}

function renderList(arr){
  elCount.textContent = `${arr.length}/${PEOPLE.length}`;
  elList.innerHTML='';
  arr.forEach(p=>{
    const d=document.createElement('div');
    d.className='item'+(selected===p.id?' active':'');
    d.dataset.id=p.id;
    d.innerHTML=`<div><b>${esc(p.name||p.name_raw||p.id)}</b></div><div class='small'>${p.id}${p.surname?(' · '+esc(p.surname)):''}</div>`;
    d.onclick=()=>select(p.id,true);
    elList.appendChild(d);
  });
}

function fmtEvents(arr){
  if(!arr||!arr.length) return '—';
  return arr.map(e=>`${esc(e.date||'')} ${e.place?('· '+esc(e.place)):''} ${e.note?('('+esc(e.note)+')'):''}`).join('<br>');
}

function links(ids){
  if(!ids||!ids.length) return '<span class="small">—</span>';
  return ids.map(id=>`<a href='#' data-j='${id}' class='j'>${id} — ${esc((MAP[id]?.name)||MAP[id]?.name_raw||'')}</a>`).join('<br>');
}

function renderDetails(id){
  const p=MAP[id]; if(!p) return;
  selected=id;

  const hasEvents=(arr)=>Array.isArray(arr) && arr.some(e=> (e.date||e.place||e.note||'').trim());
  const row=(title,val)=>`<div class='row'><div class='k'>${title}</div><div class='v'>${val}</div></div>`;

  let html=`
    <div class='row'><b style='font-size:18px'>${esc(p.name||p.name_raw||id)}</b></div>
    <div class='row small'>${esc(p.id)} ${p.sex?(' · '+esc(p.sex)):''} ${p.rin?(' · RIN '+esc(p.rin)):''}</div>
    ${row('Рождение', fmtEvents(p.birth))}
    ${hasEvents(p.death) ? row('Смерть', fmtEvents(p.death)) : ''}
    ${hasEvents(p.burial) ? row('Погребение', fmtEvents(p.burial)) : ''}
    ${hasEvents(p.residence) ? row('Проживание', fmtEvents(p.residence)) : ''}
    ${row('Родители', links(p.parents))}
    ${p.children?.length ? row('Дети', links(p.children)) : ''}
    ${p.spouses?.length ? row('Супруги', links(p.spouses)) : ''}
    <div class='row'><details><summary>RAW GEDCOM (все поля)</summary><pre>${esc(p.raw||'')}</pre></details></div>
  `;

  elDetails.innerHTML=html;
  elDetails.querySelectorAll('.j').forEach(a=>a.onclick=(e)=>{e.preventDefault(); select(a.dataset.j,true);});
}

function shortName(raw,id,max=24){
  const n=(raw||id||'').replaceAll('/','').trim();
  return n.length>max ? (n.slice(0,max-1)+'…') : n;
}

function splitName2(raw,id,maxLine=16){
  const full=(raw||id||'').replaceAll('/','').trim();
  const words=full.split(/\s+/).filter(Boolean);
  if(!words.length) return [id,''];
  let l1='', l2='';
  for(const w of words){
    if((l1 ? l1+' '+w : w).length <= maxLine){
      l1 = l1 ? (l1+' '+w) : w;
    } else {
      l2 = (l2 ? l2+' '+w : w);
    }
  }
  if(!l2 && l1.length > maxLine){
    l2 = l1.slice(maxLine-1);
    l1 = l1.slice(0,maxLine-1);
  }
  if(l2.length > maxLine+2) l2 = l2.slice(0,maxLine+1)+'…';
  return [l1, l2];
}

function years(p){
  const b=(p.birth&&p.birth[0]&&p.birth[0].date)||'';
  const d=(p.death&&p.death[0]&&p.death[0].date)||'';
  const y=s=>{const m=(s||'').match(/(\d{4})/); return m?m[1]:''};
  const by=y(b), dy=y(d);
  if(!by && !dy) return '';
  return `${by||'?'}—${dy||''}`;
}

function buildGraphModel(){
  const parents=new Map(), children=new Map();
  PEOPLE.forEach(p=>{parents.set(p.id,new Set()); children.set(p.id,new Set());});

  FAMS.forEach(f=>{
    const ps=[...(f.husband||[]), ...(f.wife||[])].filter(id=>MAP[id]);
    const ch=(f.children||[]).filter(id=>MAP[id]);
    ps.forEach(p=>ch.forEach(c=>{children.get(p).add(c); parents.get(c).add(p);}));
  });

  // === GENERATION ASSIGNMENT relative to Ed (I1) ===
  // Gen 0 = Ed, +1 = parents, +2 = grandparents, etc.
  // This ensures same-generation relatives align on one row.
  const ROOT_ID = MAP['I1'] ? 'I1' : PEOPLE[0]?.id;
  const gen=new Map();
  gen.set(ROOT_ID, 0);
  const q=[ROOT_ID];
  while(q.length){
    const u=q.shift();
    const g=gen.get(u);
    for(const p of parents.get(u)){
      if(!gen.has(p)){ gen.set(p, g+1); q.push(p); }
    }
    for(const c of children.get(u)){
      if(!gen.has(c)){ gen.set(c, g-1); q.push(c); }
    }
  }
  // Spouse alignment: ensure spouses share the same generation
  let changed=true;
  while(changed){
    changed=false;
    FAMS.forEach(f=>{
      const ps=[...(f.husband||[]), ...(f.wife||[])].filter(id=>MAP[id]);
      const ch=(f.children||[]).filter(id=>MAP[id]);
      const knownP=ps.filter(id=>gen.has(id));
      const knownC=ch.filter(id=>gen.has(id));
      if(knownP.length){
        const pg=Math.max(...knownP.map(id=>gen.get(id)));
        for(const id of ps){ if(!gen.has(id)){ gen.set(id,pg); changed=true; } }
        for(const id of ch){ if(!gen.has(id)){ gen.set(id,pg-1); changed=true; } }
      } else if(knownC.length){
        const cg=Math.min(...knownC.map(id=>gen.get(id)));
        for(const id of ps){ if(!gen.has(id)){ gen.set(id,cg+1); changed=true; } }
      }
    });
  }
  PEOPLE.forEach(p=>{ if(!gen.has(p.id)) gen.set(p.id,0); });

  // Convert: highest gen number = top row (level 0), Ed = bottom
  const maxGen=Math.max(...[...gen.values()]);
  const level=new Map();
  PEOPLE.forEach(p=>level.set(p.id, maxGen - gen.get(p.id)));

  const layers={};
  PEOPLE.forEach(p=>{const l=level.get(p.id); (layers[l]=layers[l]||[]).push(p.id);});
  Object.values(layers).forEach(arr=>arr.sort((a,b)=>
    (MAP[a].surname||'').localeCompare(MAP[b].surname||'','ru') ||
    (MAP[a].name||'').localeCompare(MAP[b].name||'','ru')
  ));

  // reorder for fewer crossings (top-down by parents + bottom-up by children)
  const levelKeys=Object.keys(layers).map(Number).sort((a,b)=>a-b);
  for(let pass=0; pass<6; pass++){
    // top-down (parent barycenter)
    for(const l of levelKeys){
      const arr=layers[l], prev=layers[l-1]||[];
      arr.sort((a,b)=>{
        const avg=(id)=>{
          const pars=[...parents.get(id)];
          if(!pars.length) return prev.length + 100;
          return pars.reduce((s,p)=>s + (prev.indexOf(p)>=0?prev.indexOf(p):prev.length+5),0)/pars.length;
        };
        return avg(a)-avg(b);
      });
    }

    // bottom-up (child barycenter)
    for(const l of [...levelKeys].reverse()){
      const arr=layers[l], next=layers[l+1]||[];
      arr.sort((a,b)=>{
        const avg=(id)=>{
          const ch=[...children.get(id)];
          if(!ch.length) return next.length + 100;
          return ch.reduce((s,c)=>s + (next.indexOf(c)>=0?next.indexOf(c):next.length+5),0)/ch.length;
        };
        return avg(a)-avg(b);
      });
    }
  }

  const margin=24;
  const maxCols=Math.max(...Object.values(layers).map(a=>a.length));
  const depth=Math.max(...levelKeys);

  // compress base geometry so full tree stays readable on one screen more often
  const targetW=1500, targetH=920;
  const gx = maxCols > 9 ? 10 : 14;
  const gy = depth > 7 ? 90 : 100;

  const nodeW = Math.max(104, Math.min(170,
    Math.floor((targetW - 2*margin - Math.max(0,maxCols-1)*gx) / maxCols)
  ));
  const nodeH = Math.max(46, Math.min(58,
    Math.floor((targetH - 2*margin - Math.max(0,depth)*gy) / (depth+1))
  ));

  const worldW = Math.max(900, margin*2 + maxCols*nodeW + Math.max(0,maxCols-1)*gx);
  const worldH = Math.max(620, margin*2 + (depth+1)*nodeH + Math.max(0,depth)*gy);

  const xy={};
  const minLevel = Math.min(...levelKeys);
  const step = nodeW + gx;

  for(const l of levelKeys){
    const arr=layers[l];
    const rowW=arr.length*nodeW + Math.max(0,arr.length-1)*gx;
    const y=margin + l*(nodeH+gy);

    let baseX = (worldW-rowW)/2;

    // Shift row toward parent barycenter so children sit under their parents.
    if(l !== minLevel){
      const candidates=[];
      arr.forEach((id,idx)=>{
        const pars=[...parents.get(id)].filter(pid=>xy[pid]);
        if(!pars.length) return;
        const parentCenter = pars.reduce((s,pid)=>s + (xy[pid].x + nodeW/2), 0) / pars.length;
        const offset = parentCenter - (idx*step + nodeW/2);
        candidates.push(offset);
      });
      if(candidates.length){
        baseX = candidates.reduce((s,v)=>s+v,0)/candidates.length;
      }
    }

    const minX=margin;
    const maxX=Math.max(minX, worldW - rowW - margin);
    baseX=Math.max(minX, Math.min(maxX, baseX));

    let x=baseX;
    arr.forEach(id=>{xy[id]={x,y}; x+=step;});
  }

  graph={xy,nodeW,nodeH,worldW,worldH};
}

function applyViewBox(){
  svg.setAttribute('viewBox',`${view.x} ${view.y} ${view.w} ${view.h}`);
}

function fitView(){
  if(!graph) return;
  view={x:0,y:0,w:graph.worldW,h:graph.worldH};
  applyViewBox();
}

function clampView(){
  if(!graph) return;
  view.w=Math.max(graph.worldW*0.12, Math.min(graph.worldW, view.w));
  view.h=Math.max(graph.worldH*0.12, Math.min(graph.worldH, view.h));
  view.x=Math.max(0, Math.min(graph.worldW-view.w, view.x));
  view.y=Math.max(0, Math.min(graph.worldH-view.h, view.y));
}

function zoom(factor){
  if(!graph) return;
  const cx=view.x+view.w/2, cy=view.y+view.h/2;
  view.w*=factor; view.h*=factor;
  clampView();
  view.x=cx-view.w/2; view.y=cy-view.h/2;
  clampView();
  applyViewBox();
}

function centerOnSelected(){
  if(!graph || !selected || !graph.xy[selected]) return;
  const c=graph.xy[selected];
  const cx=c.x+graph.nodeW/2, cy=c.y+graph.nodeH/2;
  view.x=cx-view.w/2; view.y=cy-view.h/2;
  clampView();
  applyViewBox();
}

function drawGraph(){
  if(!graph) return;
  svg.innerHTML='';

  const {xy,nodeW,nodeH}=graph;

  // === FAMILY COLOR PALETTE ===
  const FAMILY_COLORS = [
    '#6ec6ff', '#f7a072', '#a78bfa', '#4ade80', '#f472b6',
    '#fbbf24', '#67e8f9', '#c084fc', '#fb923c', '#86efac',
    '#f87171', '#38bdf8', '#a3e635', '#e879f9', '#fcd34d',
    '#5eead4', '#fb7185',
  ];

  // Build occupancy grid: for each level, list of {left,right} rectangles
  const occupancy = {};
  PEOPLE.forEach(p=>{
    const pos=xy[p.id]; if(!pos) return;
    const l = Math.round(pos.y); // approx level y
    if(!occupancy[l]) occupancy[l]=[];
    occupancy[l].push({left:pos.x, right:pos.x+nodeW, id:p.id});
  });

  // Build level Y ranges (nodeTop→nodeBottom) for collision detection
  const levelYRanges = {};
  PEOPLE.forEach(p=>{
    const pos=xy[p.id]; if(!pos) return;
    const ly = pos.y;
    if(!levelYRanges[ly]) levelYRanges[ly]={top:ly, bottom:ly+nodeH, nodes:[]};
    levelYRanges[ly].nodes.push({left:pos.x, right:pos.x+nodeW, id:p.id});
  });

  // Find a clear vertical X channel that doesn't overlap any node on intermediate levels
  function findClearChannel(fromY, toY, preferX, famMembers){
    // Collect all node rects on levels between fromY and toY
    const blocked = [];
    const pad = 4; // padding around nodes
    Object.values(levelYRanges).forEach(lr=>{
      if(lr.top > fromY && lr.bottom < toY){ // strictly between
        lr.nodes.forEach(n=>{
          if(!famMembers.has(n.id)){
            blocked.push({left:n.left-pad, right:n.right+pad});
          }
        });
      }
    });
    // Check if preferX is clear
    if(!blocked.some(b => preferX > b.left && preferX < b.right)) return preferX;
    // Try offsets left/right
    for(let d=8; d<graph.worldW; d+=6){
      const xl = preferX - d;
      if(xl > 4 && !blocked.some(b => xl > b.left && xl < b.right)) return xl;
      const xr = preferX + d;
      if(xr < graph.worldW-4 && !blocked.some(b => xr > b.left && xr < b.right)) return xr;
    }
    return preferX; // fallback
  }

  const INTO = 6;

  // === GLOBAL Y-LANE REGISTRY: prevent ANY horizontal bars from sharing the same Y ===
  const usedYLanes = []; // [{y, x1, x2}] — all reserved horizontal lane segments

  function reserveYLane(y, x1, x2){
    usedYLanes.push({y, x1: Math.min(x1,x2), x2: Math.max(x1,x2)});
  }
  function isYLaneFree(y, x1, x2){
    const a=Math.min(x1,x2), b=Math.max(x1,x2);
    return !usedYLanes.some(l => Math.abs(l.y - y) < 5 && l.x1 < b && a < l.x2);
  }
  function findFreeYLane(preferY, x1, x2, minY, maxY){
    if(isYLaneFree(preferY, x1, x2)) return preferY;
    for(let d=5; d < (maxY-minY)+60; d+=5){
      const yUp = preferY - d;
      if(yUp >= minY && isYLaneFree(yUp, x1, x2)) return yUp;
      const yDown = preferY + d;
      if(yDown <= maxY && isYLaneFree(yDown, x1, x2)) return yDown;
    }
    return preferY;
  }

  // === GLOBAL X-LANE REGISTRY: prevent vertical lines from sharing the same X in same Y range ===
  const usedXLanes = []; // [{x, y1, y2}]

  function reserveXLane(x, y1, y2){
    usedXLanes.push({x, y1: Math.min(y1,y2), y2: Math.max(y1,y2)});
  }
  function isXLaneFree(x, y1, y2){
    const a=Math.min(y1,y2), b=Math.max(y1,y2);
    return !usedXLanes.some(l => Math.abs(l.x - x) < 3 && l.y1 < b && a < l.y2);
  }
  function findFreeXLane(preferX, y1, y2){
    if(isXLaneFree(preferX, y1, y2)) return preferX;
    for(let d=5; d < graph.worldW; d+=5){
      const xl = preferX - d;
      if(xl > 4 && isXLaneFree(xl, y1, y2)) return xl;
      const xr = preferX + d;
      if(xr < graph.worldW-4 && isXLaneFree(xr, y1, y2)) return xr;
    }
    return preferX;
  }

  // === ANCHOR OFFSET: when a person appears in multiple families, offset attachment points ===
  const anchorUsage = {};
  FAMS.forEach((f, fi)=>{
    const ps=[...(f.husband||[]), ...(f.wife||[])].filter(id=>xy[id]);
    const ch=(f.children||[]).filter(id=>xy[id]);
    if(!ps.length || !ch.length) return;
    ps.forEach(id=>{
      if(!anchorUsage[id]) anchorUsage[id]={asParent:[],asChild:[]};
      anchorUsage[id].asParent.push(fi);
    });
    ch.forEach(id=>{
      if(!anchorUsage[id]) anchorUsage[id]={asParent:[],asChild:[]};
      anchorUsage[id].asChild.push(fi);
    });
  });

  function getAnchorXOffset(personId, role, fi){
    const u = anchorUsage[personId];
    if(!u) return 0;
    const allFams = [...new Set([...u.asParent, ...u.asChild])];
    if(allFams.length <= 1) return 0;
    const idx = allFams.indexOf(fi);
    const total = allFams.length;
    const spread = Math.min(nodeW * 0.4, total * 10);
    return (idx - (total-1)/2) * (spread / Math.max(1, total-1));
  }

  FAMS.forEach((f, fi)=>{
    const ps=[...(f.husband||[]), ...(f.wife||[])].filter(id=>xy[id]);
    const ch=(f.children||[]).filter(id=>xy[id]);
    if(!ps.length || !ch.length) return;

    const color = FAMILY_COLORS[fi % FAMILY_COLORS.length];
    const famMembers = new Set([...ps, ...ch]);

    const famG=document.createElementNS('http://www.w3.org/2000/svg','g');
    famG.setAttribute('stroke', color);
    famG.setAttribute('fill','none');
    famG.setAttribute('stroke-width','1.8');
    famG.setAttribute('stroke-linecap','round');
    famG.setAttribute('stroke-linejoin','round');
    famG.setAttribute('shape-rendering','geometricPrecision');

    const parentAnchors=ps.map(id=>({x:xy[id].x+nodeW/2+getAnchorXOffset(id,'parent',fi), y:xy[id].y+nodeH-INTO}));
    const childAnchors=ch.map(id=>({x:xy[id].x+nodeW/2+getAnchorXOffset(id,'child',fi), y:xy[id].y+INTO}));

    const parentBottomEdge = Math.max(...ps.map(id=>xy[id].y+nodeH));
    const childTopEdge = Math.min(...ch.map(id=>xy[id].y));

    const hubX = (Math.min(...parentAnchors.map(a=>a.x)) + Math.max(...parentAnchors.map(a=>a.x))) / 2;

    // Estimate full X extents that bars will span (parents + hub + children)
    const allBarX = [...parentAnchors.map(a=>a.x), ...childAnchors.map(a=>a.x), hubX];
    const fullBarLeft = Math.min(...allBarX) - 10;
    const fullBarRight = Math.max(...allBarX) + 10;

    // Handle split-level families (where parents and children overlap in Y)
    // Use the actual vertical space available between parent anchors and child anchors
    const parentAnchorBottom = Math.max(...parentAnchors.map(a=>a.y));
    const childAnchorTop = Math.min(...childAnchors.map(a=>a.y));
    const effectiveGapTop = Math.min(parentAnchorBottom, childAnchorTop);
    const effectiveGapBottom = Math.max(parentAnchorBottom, childAnchorTop);
    const gapMidpoint = (effectiveGapTop + effectiveGapBottom) / 2;
    
    // Find free Y lanes using the FULL bar extent so no cross-family overlap
    const preferYMid = effectiveGapTop + Math.min(14, (effectiveGapBottom - effectiveGapTop) * 0.3);
    const preferYChild = effectiveGapBottom - Math.min(14, (effectiveGapBottom - effectiveGapTop) * 0.3);
    
    const yMid = findFreeYLane(preferYMid, fullBarLeft, fullBarRight, effectiveGapTop, effectiveGapBottom);
    const yChildBar = findFreeYLane(preferYChild, fullBarLeft, fullBarRight, effectiveGapTop, effectiveGapBottom);

    // Detect multi-level gap: if there are intermediate levels with nodes between parents and children
    const multiLevel = (effectiveGapBottom - effectiveGapTop) > (nodeH + 40);

    // === PARENT SIDE ===
    parentAnchors.forEach(a=>{
      const ax = findFreeXLane(a.x, a.y, yMid);
      const line=document.createElementNS('http://www.w3.org/2000/svg','line');
      line.setAttribute('x1',ax); line.setAttribute('y1',a.y);
      line.setAttribute('x2',ax); line.setAttribute('y2',yMid);
      famG.appendChild(line);
      reserveXLane(ax, a.y, yMid);
      a._ax = ax; // store adjusted X for bar
    });
    if(parentAnchors.length>1){
      const h=document.createElementNS('http://www.w3.org/2000/svg','line');
      const pxs = parentAnchors.map(a=>a._ax||a.x);
      h.setAttribute('x1', Math.min(...pxs));
      h.setAttribute('x2', Math.max(...pxs));
      h.setAttribute('y1', yMid); h.setAttribute('y2', yMid);
      famG.appendChild(h);
      reserveYLane(yMid, fullBarLeft, fullBarRight);
    }

    // Marriage dot
    const dot=document.createElementNS('http://www.w3.org/2000/svg','circle');
    dot.setAttribute('cx',hubX); dot.setAttribute('cy',yMid);
    dot.setAttribute('r','3'); dot.setAttribute('fill',color);
    famG.appendChild(dot);

    // === HUB → CHILDREN with obstacle avoidance ===
    let hubEndX = hubX;
    if(multiLevel){
      const channelX = findClearChannel(yMid, yChildBar, hubX, famMembers);
      const freeChX = findFreeXLane(channelX, yMid, yChildBar);
      hubEndX = freeChX;

      const path=document.createElementNS('http://www.w3.org/2000/svg','polyline');
      const pts = [
        `${hubX},${yMid}`,
        `${freeChX},${yMid}`,
        `${freeChX},${yChildBar}`,
      ];
      path.setAttribute('points', pts.join(' '));
      famG.appendChild(path);
      reserveXLane(freeChX, yMid, yChildBar);
    } else {
      // Direct: hub → childBar
      const freeHubX = findFreeXLane(hubX, yMid, yChildBar);
      hubEndX = freeHubX;
      const vDown=document.createElementNS('http://www.w3.org/2000/svg','line');
      vDown.setAttribute('x1',freeHubX); vDown.setAttribute('y1',yMid);
      vDown.setAttribute('x2',freeHubX); vDown.setAttribute('y2',yChildBar);
      famG.appendChild(vDown);
      reserveXLane(freeHubX, yMid, yChildBar);
    }

    // Horizontal bar across children + connect to routing
    const allX = childAnchors.map(a=>a.x);
    allX.push(hubEndX);
    const barLeft = Math.min(...allX);
    const barRight = Math.max(...allX);
    if(barLeft !== barRight){
      const hBar=document.createElementNS('http://www.w3.org/2000/svg','line');
      hBar.setAttribute('x1', barLeft); hBar.setAttribute('x2', barRight);
      hBar.setAttribute('y1', yChildBar); hBar.setAttribute('y2', yChildBar);
      famG.appendChild(hBar);
      reserveYLane(yChildBar, fullBarLeft, fullBarRight);
    }

    // Each child: vertical from bar into node
    childAnchors.forEach(a=>{
      const ax = findFreeXLane(a.x, yChildBar, a.y);
      const line=document.createElementNS('http://www.w3.org/2000/svg','line');
      line.setAttribute('x1',ax); line.setAttribute('y1',yChildBar);
      line.setAttribute('x2',ax); line.setAttribute('y2',a.y);
      famG.appendChild(line);
      reserveXLane(ax, yChildBar, a.y);
    });

    svg.appendChild(famG);
  });

  const nodes=document.createElementNS('http://www.w3.org/2000/svg','g');
  PEOPLE.forEach(p=>{
    const pos=xy[p.id]; if(!pos) return;
    const g=document.createElementNS('http://www.w3.org/2000/svg','g');
    g.classList.add('node'); g.dataset.id=p.id;

    const isKey=['I1','I7','I16','I17'].includes(p.id);
    const isMention=['I135','I263','I265','I268'].includes(p.id);

    let fill='var(--node)', stroke='var(--node-stroke)';
    if(isKey){ fill='var(--node-key)'; stroke='var(--node-key-stroke)'; }
    else if(isMention){ fill='var(--node-mention)'; stroke='var(--node-mention-stroke)'; }
    else if((p.sex||'').toUpperCase()==='M'){ fill='var(--male)'; stroke='var(--male-stroke)'; }
    else if((p.sex||'').toUpperCase()==='F'){ fill='var(--female)'; stroke='var(--female-stroke)'; }

    const rect=document.createElementNS('http://www.w3.org/2000/svg','rect');
    rect.setAttribute('x',pos.x); rect.setAttribute('y',pos.y);
    rect.setAttribute('width',nodeW); rect.setAttribute('height',nodeH);
    rect.setAttribute('fill',fill); rect.setAttribute('stroke',stroke);

    const [line1, line2] = splitName2(p.name||p.name_raw,p.id, Math.max(12, Math.floor((nodeW-16)/7.6)));

    const t1=document.createElementNS('http://www.w3.org/2000/svg','text');
    t1.setAttribute('x',pos.x+8); t1.setAttribute('y',pos.y+18);
    t1.setAttribute('font-size', nodeW<120 ? '10.2' : '11.5');
    t1.setAttribute('fill','#121a27');
    t1.textContent=line1;

    const t1b=document.createElementNS('http://www.w3.org/2000/svg','text');
    t1b.setAttribute('x',pos.x+8); t1b.setAttribute('y',pos.y+32);
    t1b.setAttribute('font-size', nodeW<120 ? '10.2' : '11.5');
    t1b.setAttribute('fill','#121a27');
    t1b.textContent=line2 || '';

    const t2=document.createElementNS('http://www.w3.org/2000/svg','text');
    t2.setAttribute('x',pos.x+8); t2.setAttribute('y',pos.y+nodeH-8);
    t2.setAttribute('font-size', nodeW<120 ? '9.6' : '10.6');
    t2.setAttribute('fill','#314764');
    const yy=years(p);
    t2.textContent=yy || '';

    const title=document.createElementNS('http://www.w3.org/2000/svg','title');
    title.textContent=`${(p.name||p.name_raw||p.id).replaceAll('/','').trim()}${yy?(' · '+yy):''}`;

    g.appendChild(rect); g.appendChild(t1); g.appendChild(t1b); g.appendChild(t2); g.appendChild(title);
    g.onclick=()=>select(p.id,true);
    nodes.appendChild(g);
  });

  svg.appendChild(nodes);
  applyViewBox();
  highlightSelected();
}

function highlightSelected(){
  svg.querySelectorAll('.node rect').forEach(r=>r.setAttribute('stroke-width','1.4'));
  if(!selected) return;
  const n=svg.querySelector(`.node[data-id='${selected}'] rect`);
  if(n){ n.setAttribute('stroke','#ef4444'); n.setAttribute('stroke-width','3'); }
}

function select(id,center=false){
  selected=id;
  renderDetails(id);
  renderList(PEOPLE);
  highlightSelected();
  if(center) centerOnSelected();
}

function bindGraphInteractions(){
  let dragging=false, start=null, startView=null;

  svg.addEventListener('mousedown',(e)=>{
    if(e.button!==0) return;
    dragging=true;
    start={x:e.clientX,y:e.clientY};
    startView={...view};
  });

  window.addEventListener('mousemove',(e)=>{
    if(!dragging) return;
    const dxPx=e.clientX-start.x;
    const dyPx=e.clientY-start.y;
    const scaleX=startView.w/host.clientWidth;
    const scaleY=startView.h/host.clientHeight;
    view.x=startView.x - dxPx*scaleX;
    view.y=startView.y - dyPx*scaleY;
    clampView();
    applyViewBox();
  });

  window.addEventListener('mouseup',()=>{ dragging=false; });

  // Deterministic trackpad behavior:
  // - 2-finger scroll = PAN
  // - zoom only on explicit Ctrl+wheel/pinch signal
  // This avoids random mode switching on noisy gesture streams.
  function normalizeWheelDelta(e){
    let dx=e.deltaX, dy=e.deltaY;
    if(e.deltaMode===1){ // lines
      dx*=16; dy*=16;
    } else if(e.deltaMode===2){ // pages
      dx*=host.clientWidth;
      dy*=host.clientHeight;
    }
    return {dx,dy};
  }

  let wheelMode='pan';
  let wheelModeUntil=0;
  let pendingPanX=0, pendingPanY=0, panRaf=0;

  function flushPan(){
    panRaf=0;
    if(!pendingPanX && !pendingPanY) return;
    view.x += pendingPanX;
    view.y += pendingPanY;
    pendingPanX=0; pendingPanY=0;
    clampView();
    applyViewBox();
  }

  host.addEventListener('wheel',(e)=>{
    e.preventDefault();
    e.stopPropagation();

    const now=performance.now();
    const {dx,dy}=normalizeWheelDelta(e);
    if(Math.abs(dx)<0.01 && Math.abs(dy)<0.01) return;

    const wantsZoom = !!e.ctrlKey; // keep strict: Ctrl/pinch only

    // Lock interaction mode for a short burst to prevent flicker pan<->zoom.
    if(now > wheelModeUntil){
      wheelMode = wantsZoom ? 'zoom' : 'pan';
    } else if(wheelMode==='zoom' && !wantsZoom){
      // Keep zoom mode until burst ends.
    } else if(wheelMode==='pan' && wantsZoom){
      // Only switch to zoom in-burst for clearly zoom-like movement.
      if(Math.abs(dy) > Math.abs(dx)*1.25) wheelMode='zoom';
    }
    wheelModeUntil = now + (wheelMode==='zoom' ? 180 : 120);

    if(wheelMode==='zoom'){
      const strength=Math.min(1.7, Math.max(0.6, Math.abs(dy)/140));
      const factor = dy<0 ? (1 - 0.14*strength) : (1 + 0.14*strength);
      zoom(Math.max(0.78, Math.min(1.24, factor)));
      return;
    }

    // Pan path (scheduled on RAF to avoid choppy delayed response).
    const panBoost=1.45;
    const scaleX=(view.w/host.clientWidth)*panBoost;
    const scaleY=(view.h/host.clientHeight)*panBoost;
    pendingPanX += dx * scaleX;
    pendingPanY += dy * scaleY;
    if(!panRaf) panRaf=requestAnimationFrame(flushPan);
  }, {passive:false});

  fitBtn.onclick=()=>fitView();
  zoomInBtn.onclick=()=>zoom(0.88);
  zoomOutBtn.onclick=()=>zoom(1.14);
  centerBtn.onclick=()=>centerOnSelected();

  window.addEventListener('resize',()=>{
    // keep same center while resizing
    const cx=view.x+view.w/2, cy=view.y+view.h/2;
    drawGraph();
    view.x=cx-view.w/2; view.y=cy-view.h/2;
    clampView();
    applyViewBox();
  });
}

async function init(){
  const r=await fetch('data.json');
  DATA=await r.json();
  PEOPLE=DATA.people;
  FAMS=DATA.families;
  MAP=Object.fromEntries(PEOPLE.map(p=>[p.id,p]));

  elMeta.textContent=`Людей: ${DATA.meta.people_count} · Семей: ${DATA.meta.families_count} · ${DATA.meta.generator}`;
  renderVersionInfo();

  renderList(PEOPLE);
  buildGraphModel();
  fitView();
  drawGraph();
  bindGraphInteractions();

  const start = MAP['I1'] ? 'I1' : PEOPLE[0]?.id;
  if(start) select(start,true);

  elQ.oninput=()=>{
    const q=elQ.value.trim().toLowerCase();
    const arr=!q ? PEOPLE : PEOPLE.filter(p=>`${p.id} ${p.name} ${p.name_raw} ${p.surname} ${p.given}`.toLowerCase().includes(q));
    renderList(arr);
  };
}

init().catch(err=>{
  console.error(err);
  elMeta.textContent='Ошибка загрузки data.json';
});
</script>
</body>
</html>
