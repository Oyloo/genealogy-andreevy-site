<!doctype html>
<html lang="ru">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
<meta name="theme-color" content="#000000" />
<meta name="color-scheme" content="dark" />
<title>–ì–µ–Ω–µ–∞–ª–æ–≥–∏—è ‚Äî custom</title>
<style>
:root{
  --bg:#000; --panel:#111a2b; --line:#24324d; --txt:#e8eef9; --muted:#9fb0cc;
  --graph-bg:#0a0a0a; --edge:#87a4d4;
  --node:#b8a8ff; --node-stroke:#8f74ff;
  --male:#9cc8ff; --male-stroke:#3b82f6;
  --female:#f8b4d8; --female-stroke:#db2777;
  --node-key:#93c5fd; --node-key-stroke:#2563eb;
  --node-mention:#fdba74; --node-mention-stroke:#ea580c;
}
*{margin:0;padding:0;box-sizing:border-box}
html{width:100%;background:#000}
body{width:100%;height:100dvh;background:#000;font-family:Inter,Segoe UI,Arial,sans-serif;color:var(--txt);touch-action:manipulation;display:flex;flex-direction:column;overflow:hidden}
header{padding:max(0px,env(safe-area-inset-top)) 16px 10px 16px;border-bottom:1px solid var(--line);background:#000;backdrop-filter:blur(6px);position:sticky;top:0;z-index:20;flex-shrink:0}
.headerRow{display:flex;align-items:center;gap:12px;min-width:0;white-space:nowrap;overflow:hidden}
h1{margin:0;font-size:16px;flex:0 1 auto;min-width:0;overflow:hidden;text-overflow:ellipsis}
.titleShort{display:none}
.meta{margin-top:0;font-size:12px;color:var(--muted);overflow:hidden;text-overflow:ellipsis}
#meta{flex:0 1 36%}
#version{flex:1 1 auto;opacity:.88}

@media(max-width:900px){
  header{padding:8px 10px}
  .headerRow{gap:8px}
  .titleLong{display:none}
  .titleShort{display:inline}
  h1{font-size:14px;flex:0 0 auto}
  #meta{display:none}
  #version{font-size:11px}
}
@media(max-width:560px){
  h1{max-width:40vw}
}
.layout{display:grid;grid-template-columns:280px 1fr 370px;grid-template-rows:minmax(0,1fr);gap:10px;padding:10px;width:100%;flex:1;min-height:0;overflow:hidden}
.panel{border:1px solid var(--line);background:var(--panel);border-radius:12px;overflow:hidden;display:flex;flex-direction:column}
.panel h2{margin:0;padding:9px 12px;border-bottom:1px solid var(--line);font-size:12px;font-weight:600;letter-spacing:0.02em;text-transform:uppercase;color:#c6d6f2;display:flex;justify-content:space-between;align-items:center;gap:8px}
.content{padding:10px;overflow-y:auto;overflow-x:hidden;flex:1 1 auto}
input{width:100%;padding:9px 10px;border-radius:9px;border:1px solid #294063;background:#0c1628;color:#e8eef9}
.item{margin-top:6px;border:1px solid #253754;background:#0d1728;padding:8px;border-radius:9px;cursor:pointer;white-space:nowrap;overflow:hidden;text-overflow:ellipsis}
.item.active{border-color:#67b0ff;background:#10203a}
.small{font-size:12px;color:var(--muted)}

/* visible scrollbars */
.content::-webkit-scrollbar{width:10px;height:10px}
.content::-webkit-scrollbar-track{background:#0b1527;border-radius:8px}
.content::-webkit-scrollbar-thumb{background:#35507a;border-radius:8px}
.content::-webkit-scrollbar-thumb:hover{background:#4a6ea8}

#graphHost{position:relative;flex:1;background:var(--graph-bg);border-radius:8px;border:1px solid #253b5f;overflow:hidden;overscroll-behavior:none;touch-action:manipulation}
#graphSvg{position:absolute;inset:0;width:100%;height:100%;user-select:none}
.legend{display:flex;gap:10px;align-items:center;flex-wrap:wrap}
.legend span{display:inline-flex;align-items:center;gap:5px;font-size:11px;color:#cbd8ef}
.dot{width:10px;height:10px;border-radius:50%}
.ctrls{display:flex;gap:6px;align-items:center;flex-wrap:wrap}
.btn{font-size:12px;padding:4px 8px;border-radius:8px;border:1px solid #3b4c6a;background:#101a2d;color:#d9e7ff;cursor:pointer}
.btn:hover{border-color:#67b0ff;color:#fff}
.hint{position:absolute;left:8px;bottom:8px;background:#000000d0;color:#d9e7ff;font-size:11px;padding:4px 7px;border-radius:6px;pointer-events:none}

svg text{font-family:Arial,sans-serif}
.node rect{rx:10;ry:10;stroke-width:1.4;cursor:pointer}
.node:hover rect{stroke-width:2.2}

.row{margin:8px 0}
.k{font-size:11px;color:#9cb1d6;text-transform:uppercase;letter-spacing:.04em}
.v{margin-top:3px;white-space:pre-wrap;word-break:break-word}
a{color:#8ec7ff}
pre{white-space:pre-wrap;background:#0b1423;border:1px solid #24324d;border-radius:8px;padding:8px;font-size:12px;line-height:1.35;max-height:380px;overflow:auto}
details summary{cursor:pointer;color:#b9cef4;font-size:12px}

@media(prefers-color-scheme:dark){
  :root{--bg:#000; --graph-bg:#0a0a0a}
  body{background:#000}
  header{background:#000}
}

@media(max-width:1300px){.layout{grid-template-columns:250px 1fr 330px}}
@media(max-width:1100px){
  body{height:auto;overflow:visible}
  .layout{grid-template-columns:1fr;grid-template-rows:auto;grid-auto-rows:auto}
  .layout > .panel:nth-child(1) .content, .layout > .panel:nth-child(3) .content{max-height:50vh}
  .layout > .panel:nth-child(2) .content{max-height:none}
  #graphHost{min-height:min(50vh, 400px);height:auto;flex:none}
}

@media(min-width:1101px){
  .layout{position:relative}
  .layout > .panel:nth-child(1), .layout > .panel:nth-child(3){
    background:rgba(10, 15, 25, 0.2) !important;
    backdrop-filter:blur(4px);
    -webkit-backdrop-filter:blur(4px);
    z-index:10;
    border-color:rgba(36, 50, 77, 0.4);
  }
  /* –î–µ–ª–∞–µ–º –≤–Ω—É—Ç—Ä–µ–Ω–Ω–∏–µ –∫–∞—Ä—Ç–æ—á–∫–∏ —Å–ø–∏—Å–∫–∞ –∏ –ø–æ–ª—è –ø–æ–ª–Ω–æ—Å—Ç—å—é –ø—Ä–æ–∑—Ä–∞—á–Ω—ã–º–∏ */
  .layout > .panel:nth-child(1) input {
    background:rgba(11, 20, 35, 0) !important;
    border:1px solid rgba(41, 64, 99, 0.5) !important;
  }
  .layout > .panel:nth-child(1) .item {
    background:rgba(11, 20, 35, 0) !important;
    border:1px solid rgba(37, 55, 84, 0.4) !important;
  }
  .layout > .panel:nth-child(3) .content {
    background:rgba(0, 0, 0, 0) !important;
  }
  .layout > .panel:nth-child(3) pre {
    background:rgba(11, 20, 35, 0.05) !important;
  }
  .layout > .panel:nth-child(1) .item.active {
    background:rgba(37, 99, 235, 0.2) !important;
    border-color:rgba(67, 130, 255, 0.6) !important;
  }
  .layout > .panel:nth-child(1) .item:hover {
    background:rgba(37, 99, 235, 0.1) !important;
  }
  .layout > .panel:nth-child(2){
    background:transparent;
    border:none;
    pointer-events:none;
    overflow:visible;
  }
  .layout > .panel:nth-child(2) h2{
    pointer-events:auto;
    background:var(--panel);
    border:1px solid var(--line);
    border-radius:12px;
    margin-bottom:8px;
    position:relative;
    z-index:10;
  }
  .layout > .panel:nth-child(2) .content{
    overflow:visible;
    padding:0;
    pointer-events:none;
  }
  .layout > .panel:nth-child(2) .legend{
    pointer-events:auto;
    background:var(--panel);
    border:1px solid var(--line);
    border-radius:8px;
    padding:8px 12px;
    margin-bottom:8px;
    align-self:flex-start; /* prevent stretching */
    position:relative;
    z-index:10;
  }
  #graphHost{
    position:absolute;
    top:0; left:0; right:0; bottom:0;
    z-index:0;
    pointer-events:auto;
    border-radius:0;
    border:none;
    background:var(--graph-bg);
  }
  #graphHost .hint{
    left:calc(280px + 20px);
    bottom:20px;
  }
}
@media(min-width:1101px) and (max-width:1300px){
  #graphHost .hint{left:calc(250px + 20px)}
}
</style>
</head>
<body>
<header>
  <div class="headerRow">
    <h1><span class="titleLong">–ì–µ–Ω–µ–∞–ª–æ–≥–∏—è (custom renderer —Å –Ω—É–ª—è, –±–µ–∑ Graphviz)</span><span class="titleShort">–ì–µ–Ω–µ–∞–ª–æ–≥–∏—è</span></h1>
    <div class="meta" id="meta">–ó–∞–≥—Ä—É–∑–∫–∞...</div>
    <div class="meta" id="version"></div>
  </div>
</header>

<div class="layout">
  <section class="panel">
    <h2><span>–õ—é–¥–∏</span><span class="small" id="listCount"></span></h2>
    <div class="content">
      <input id="q" placeholder="–ü–æ–∏—Å–∫: –∏–º—è / —Ñ–∞–º–∏–ª–∏—è / emoji" />
      <div id="list"></div>
    </div>
  </section>

  <section class="panel">
    <h2>
      <span>–°–≤—è–∑–∏</span>
      <div class="ctrls">
        <button class="btn" id="fitBtn">Fit</button>
        <button class="btn" id="zoomInBtn">+</button>
        <button class="btn" id="zoomOutBtn">‚àí</button>
        <button class="btn" id="centerBtn">Center selected</button>
      </div>
    </h2>
    <div class="content" style="padding:8px;display:flex;flex-direction:column;gap:8px;overflow:hidden">
      <div class="legend" id="legend">
        <span><i class="dot" style="background:var(--node-key)"></i> –≠–¥ + –º–∞–º–∞ + –µ—ë —Ä–æ–¥–∏—Ç–µ–ª–∏</span>
        <span><i class="dot" style="background:var(--node-mention)"></i> –ú–∏–Ω–∞–¥–æ—Ä–∞/–§–æ–º–∞–Ω–∏–¥–∞/–§–æ–º–∞–∏–¥–∞/–§–µ–¥–æ—Ä–∞</span>
        <span><i class="dot" style="background:var(--female)"></i> –ñ–µ–Ω—â–∏–Ω—ã</span>
        <span><i class="dot" style="background:var(--male)"></i> –ú—É–∂—á–∏–Ω—ã</span>
        <span style="margin-left:12px;opacity:.7">–õ–∏–Ω–∏–∏ –æ–∫—Ä–∞—à–µ–Ω—ã –ø–æ —Å–µ–º—å—è–º</span>
      </div>
      <div id="graphHost">
        <svg id="graphSvg"></svg>
        <div class="hint">–õ–ö–ú drag ‚Äî pan ¬∑ 2 –ø–∞–ª—å—Ü–∞ –Ω–∞ —Ç—Ä–µ–∫–ø–∞–¥–µ ‚Äî pan ¬∑ pinch –∏–ª–∏ Cmd/Ctrl+–∫–æ–ª–µ—Å–æ ‚Äî zoom</div>
      </div>
    </div>
  </section>

  <section class="panel">
    <h2>–ö–∞—Ä—Ç–æ—á–∫–∞ + –≤—Å–µ –ø–æ–ª—è</h2>
    <div class="content" id="details">–í—ã–±–µ—Ä–∏ —á–µ–ª–æ–≤–µ–∫–∞</div>
  </section>
</div>

<script>
let DATA, MAP={}, PEOPLE=[], FAMS=[], selected=null;
let graph=null; // {xy,nodeW,nodeH,worldW,worldH}
let view={x:0,y:0,w:100,h:100};

// Manual build marker: updates on each publish commit.
const APP_VERSION='20260225_0035';
const APP_BUILT_AT_ISO='2026-02-25T00:35:00+02:00';

const elMeta=document.getElementById('meta');
const elVersion=document.getElementById('version');
const elList=document.getElementById('list');
const elQ=document.getElementById('q');
const elDetails=document.getElementById('details');
const elCount=document.getElementById('listCount');
const host=document.getElementById('graphHost');
const svg=document.getElementById('graphSvg');

const fitBtn=document.getElementById('fitBtn');
const zoomInBtn=document.getElementById('zoomInBtn');
const zoomOutBtn=document.getElementById('zoomOutBtn');
const centerBtn=document.getElementById('centerBtn');

const esc=s=>(s??'').toString().replace(/[&<>\"]/g,c=>({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;'}[c]));

function formatAgo(ts){
  const ms=Math.max(0, Date.now()-ts.getTime());
  const m=Math.floor(ms/60000);
  if(m<1) return '—Ç–æ–ª—å–∫–æ —á—Ç–æ';
  if(m<60) return `${m} –º–∏–Ω –Ω–∞–∑–∞–¥`;
  const h=Math.floor(m/60);
  if(h<24) return `${h} —á –Ω–∞–∑–∞–¥`;
  const d=Math.floor(h/24);
  return `${d} –¥–Ω –Ω–∞–∑–∞–¥`;
}

function renderVersionInfo(){
  const cb = new URLSearchParams(location.search).get('cache_bust');
  const compact = window.matchMedia('(max-width:900px)').matches;
  const builtAt=new Date(APP_BUILT_AT_ISO);
  const builtAgo = Number.isNaN(builtAt.getTime()) ? '–Ω–µ–∏–∑–≤–µ—Å—Ç–Ω–æ' : formatAgo(builtAt);

  elVersion.textContent = compact
    ? `v${APP_VERSION} ¬∑ ${builtAgo}`
    : `–í–µ—Ä—Å–∏—è: ${APP_VERSION} ¬∑ –û–±–Ω–æ–≤–ª–µ–Ω–æ: ${builtAgo}${cb?` ¬∑ cache_bust=${cb}`:''}`;

  // Live server marker (CDN edge): show relative age too.
  fetch(window.location.href, { method:'HEAD', cache:'no-store' })
    .then(r=>{
      const lm=r.headers.get('last-modified');
      if(!lm) return;
      const d=new Date(lm);
      if(Number.isNaN(d.getTime())) return;
      elVersion.textContent += compact ? ` ¬∑ srv ${formatAgo(d)}` : ` ¬∑ –°–µ—Ä–≤–µ—Ä: ${formatAgo(d)}`;
    })
    .catch(()=>{});
}


function renderList(arr){
  elCount.textContent = `${arr.length}/${PEOPLE.length}`;
  elList.innerHTML='';
  arr.forEach(p=>{
    const d=document.createElement('div');
    d.className='item'+(selected===p.id?' active':'');
    d.dataset.id=p.id;
    d.innerHTML=`<div><b>${p.emoji} ${esc(p.name||p.name_raw||p.id)}</b></div>`;
    d.onclick=()=>select(p.id,true);
    elList.appendChild(d);
  });
}

function fmtEvents(arr){
  if(!arr||!arr.length) return '‚Äî';
  return arr.map(e=>`${esc(e.date||'')} ${e.place?('¬∑ '+esc(e.place)):''} ${e.note?('('+esc(e.note)+')'):''}`).join('<br>');
}

function links(ids){
  if(!ids||!ids.length) return '<span class="small">‚Äî</span>';
  return ids.map(id=>{const p=MAP[id]; return `<a href='#' data-j='${id}' class='j'>${p?.emoji||'üë§'} ${esc((p?.name)||p?.name_raw||'')}</a>`}).join('<br>');
}

function renderDetails(id){
  const p=MAP[id]; if(!p) return;
  selected=id;

  const hasEvents=(arr)=>Array.isArray(arr) && arr.some(e=> (e.date||e.place||e.note||'').trim());
  const row=(title,val)=>`<div class='row'><div class='k'>${title}</div><div class='v'>${val}</div></div>`;

  let html=`
    <div class='row'><b style='font-size:18px'>${esc(p.name||p.name_raw||id)}</b></div>
    <div class='row small'>${p.emoji} ¬∑ ${p.sex?esc(p.sex):''}</div>
    ${row('–†–æ–∂–¥–µ–Ω–∏–µ', fmtEvents(p.birth))}
    ${hasEvents(p.death) ? row('–°–º–µ—Ä—Ç—å', fmtEvents(p.death)) : ''}
    ${hasEvents(p.burial) ? row('–ü–æ–≥—Ä–µ–±–µ–Ω–∏–µ', fmtEvents(p.burial)) : ''}
    ${hasEvents(p.residence) ? row('–ü—Ä–æ–∂–∏–≤–∞–Ω–∏–µ', fmtEvents(p.residence)) : ''}
    ${row('–†–æ–¥–∏—Ç–µ–ª–∏', links(p.parents))}
    ${p.children?.length ? row('–î–µ—Ç–∏', links(p.children)) : ''}
    ${p.spouses?.length ? row('–°—É–ø—Ä—É–≥–∏', links(p.spouses)) : ''}
    <div class='row'><details><summary>RAW GEDCOM (–≤—Å–µ –ø–æ–ª—è)</summary><pre>${esc(p.raw||'')}</pre></details></div>
  `;

  elDetails.innerHTML=html;
  elDetails.querySelectorAll('.j').forEach(a=>a.onclick=(e)=>{e.preventDefault(); select(a.dataset.j,true);});
}

function shortName(raw,id,max=24){
  const n=(raw||id||'').replaceAll('/','').trim();
  return n.length>max ? (n.slice(0,max-1)+'‚Ä¶') : n;
}

function splitName3(raw,id,maxLine=10){
  const full=(raw||id||'').replaceAll('/','').trim();
  const words=full.split(/\s+/).filter(Boolean);
  if(!words.length) return [id,'',''];
  
  let lines=['','',''];
  let current=0;
  
  for(const w of words){
    if(current > 2) break; // max 3 lines
    
    // Try append to current
    const proposed = lines[current] ? (lines[current]+' '+w) : w;
    if(proposed.length <= maxLine){
      lines[current] = proposed;
    } else {
      // Move to next line if available
      if(current < 2) {
        current++;
        lines[current] = w; // force wrap even if w > maxLine
      } else {
        // Truncate on last line
        lines[current] = (lines[current] + ' ' + w);
      }
    }
  }
  
  // Hard limit length per line
  lines = lines.map(l => l.length > maxLine+3 ? l.slice(0,maxLine+2)+'‚Ä¶' : l);
  return lines;
}

function years(p){
  const b=(p.birth&&p.birth[0]&&p.birth[0].date)||'';
  const d=(p.death&&p.death[0]&&p.death[0].date)||'';
  const y=s=>{const m=(s||'').match(/(\d{4})/); return m?m[1]:''};
  const by=y(b), dy=y(d);
  if(!by && !dy) return '';
  return `${by||'?'}‚Äî${dy||''}`;
}

function buildGraphModel(){
  const parents=new Map(), children=new Map();
  PEOPLE.forEach(p=>{parents.set(p.id,new Set()); children.set(p.id,new Set());});

  FAMS.forEach(f=>{
    const ps=[...(f.husband||[]), ...(f.wife||[])].filter(id=>MAP[id]);
    const ch=(f.children||[]).filter(id=>MAP[id]);
    ps.forEach(p=>ch.forEach(c=>{children.get(p).add(c); parents.get(c).add(p);}));
  });

  // === GENERATION ASSIGNMENT relative to Ed (I1) ===
  // Gen 0 = Ed, +1 = parents, +2 = grandparents, etc.
  // This ensures same-generation relatives align on one row.
  const ROOT_ID = MAP['I1'] ? 'I1' : PEOPLE[0]?.id;
  const gen=new Map();
  gen.set(ROOT_ID, 0);
  const q=[ROOT_ID];
  while(q.length){
    const u=q.shift();
    const g=gen.get(u);
    for(const p of parents.get(u)){
      if(!gen.has(p)){ gen.set(p, g+1); q.push(p); }
    }
    for(const c of children.get(u)){
      if(!gen.has(c)){ gen.set(c, g-1); q.push(c); }
    }
  }
  // Fill still-unset nodes with neutral baseline first.
  PEOPLE.forEach(p=>{ if(!gen.has(p.id)) gen.set(p.id,0); });

  // Semantic normalization (compact mode):
  // - parents must stay above children
  // - spouses share one generation
  // - siblings in one family are collapsed to one generation (nearest compact level)
  // This avoids "row explosion" while preserving parent/child meaning.
  const MAX_RELAX_PASSES = 24;
  for(let pass=0; pass<MAX_RELAX_PASSES; pass++){
    let changed=false;

    FAMS.forEach(f=>{
      const ps=[...(f.husband||[]), ...(f.wife||[])].filter(id=>MAP[id]);
      const ch=(f.children||[]).filter(id=>MAP[id]);
      if(!ps.length || !ch.length) return;

      const maxChildGen = Math.max(...ch.map(id=>gen.get(id)));
      const minParentNeed = maxChildGen + 1;

      // Raise only under-elevated parents to keep parent->child direction strict.
      ps.forEach(id=>{
        if(gen.get(id) < minParentNeed){
          gen.set(id, minParentNeed);
          changed=true;
        }
      });

      // Spouses on same level.
      const parentGen = Math.max(...ps.map(id=>gen.get(id)));
      ps.forEach(id=>{
        if(gen.get(id) !== parentGen){
          gen.set(id, parentGen);
          changed=true;
        }
      });

      // Compact siblings: pull higher outliers down to the lowest sibling level,
      // but never above parentGen-1.
      const currentChildMin = Math.min(...ch.map(id=>gen.get(id)));
      const targetChildGen = Math.min(currentChildMin, parentGen - 1);
      ch.forEach(id=>{
        if(gen.get(id) > targetChildGen){
          gen.set(id, targetChildGen);
          changed=true;
        }
      });
    });

    if(!changed) break;
  }

  // Keep Ed at generation 0 after normalization.
  const rootGen = gen.get(ROOT_ID) || 0;
  if(rootGen !== 0){
    PEOPLE.forEach(p=>gen.set(p.id, gen.get(p.id) - rootGen));
  }

  // Convert: highest gen number = top row (level 0), Ed = bottom
  const maxGen=Math.max(...[...gen.values()]);
  const level=new Map();
  PEOPLE.forEach(p=>level.set(p.id, maxGen - gen.get(p.id)));

  const layers={};
  PEOPLE.forEach(p=>{const l=level.get(p.id); (layers[l]=layers[l]||[]).push(p.id);});
  Object.values(layers).forEach(arr=>arr.sort((a,b)=>
    (MAP[a].surname||'').localeCompare(MAP[b].surname||'','ru') ||
    (MAP[a].name||'').localeCompare(MAP[b].name||'','ru')
  ));

  // reorder for fewer crossings (top-down by parents + bottom-up by children)
  const levelKeys=Object.keys(layers).map(Number).sort((a,b)=>a-b);
  for(let pass=0; pass<6; pass++){
    // top-down (parent barycenter)
    for(const l of levelKeys){
      const arr=layers[l], prev=layers[l-1]||[];
      arr.sort((a,b)=>{
        const avg=(id)=>{
          const pars=[...parents.get(id)];
          if(!pars.length) return prev.length + 100;
          return pars.reduce((s,p)=>s + (prev.indexOf(p)>=0?prev.indexOf(p):prev.length+5),0)/pars.length;
        };
        return avg(a)-avg(b);
      });
    }

    // bottom-up (child barycenter)
    for(const l of [...levelKeys].reverse()){
      const arr=layers[l], next=layers[l+1]||[];
      arr.sort((a,b)=>{
        const avg=(id)=>{
          const ch=[...children.get(id)];
          if(!ch.length) return next.length + 100;
          return ch.reduce((s,c)=>s + (next.indexOf(c)>=0?next.indexOf(c):next.length+5),0)/ch.length;
        };
        return avg(a)-avg(b);
      });
    }
  }

  const margin=24;
  const maxCols=Math.max(...Object.values(layers).map(a=>a.length));
  const depth=Math.max(...levelKeys);

  // compress base geometry so full tree stays readable on one screen more often
  const targetW=1500, targetH=920;
  const gx = maxCols > 9 ? 12 : 16;
  const gy = 90; 

  // Reduce nodeW min/max to force narrower (more square) cards.
  // Old: 104-170. New: 80-120. Even more compact now: 70-100.
  // Increase nodeH slightly to accommodate wrapped text in narrower card.
  const nodeW = Math.max(70, Math.min(100,
    Math.floor((targetW - 2*margin - Math.max(0,maxCols-1)*gx) / maxCols)
  ));
  const nodeH = Math.max(64, Math.min(78,
    Math.floor((targetH - 2*margin - Math.max(0,depth)*gy) / (depth+1))
  ));

  const worldW = Math.max(900, margin*2 + maxCols*nodeW + Math.max(0,maxCols-1)*gx);
  const worldH = Math.max(620, margin*2 + (depth+1)*nodeH + Math.max(0,depth)*gy);

  const xy={};
  const minLevel = Math.min(...levelKeys);
  const step = nodeW + gx;

  for(const l of levelKeys){
    const arr=layers[l];
    const rowW=arr.length*nodeW + Math.max(0,arr.length-1)*gx;
    const y=margin + l*(nodeH+gy);

    let baseX = (worldW-rowW)/2;

    // Shift row toward parent barycenter so children sit under their parents.
    if(l !== minLevel){
      const candidates=[];
      arr.forEach((id,idx)=>{
        const pars=[...parents.get(id)].filter(pid=>xy[pid]);
        if(!pars.length) return;
        const parentCenter = pars.reduce((s,pid)=>s + (xy[pid].x + nodeW/2), 0) / pars.length;
        const offset = parentCenter - (idx*step + nodeW/2);
        candidates.push(offset);
      });
      if(candidates.length){
        baseX = candidates.reduce((s,v)=>s+v,0)/candidates.length;
      }
    }

    const minX=margin;
    const maxX=Math.max(minX, worldW - rowW - margin);
    baseX=Math.max(minX, Math.min(maxX, baseX));

    let x=baseX;
    arr.forEach(id=>{xy[id]={x,y}; x+=step;});
  }

  graph={xy,nodeW,nodeH,worldW,worldH};
}

function applyViewBox(){
  svg.setAttribute('viewBox',`${view.x} ${view.y} ${view.w} ${view.h}`);
}

function fitView(){
  if(!graph) return;
  view={x:0,y:0,w:graph.worldW,h:graph.worldH};
  applyViewBox();
}

function clampView(){
  if(!graph) return;
  view.w=Math.max(graph.worldW*0.12, Math.min(graph.worldW, view.w));
  view.h=Math.max(graph.worldH*0.12, Math.min(graph.worldH, view.h));
  view.x=Math.max(0, Math.min(graph.worldW-view.w, view.x));
  view.y=Math.max(0, Math.min(graph.worldH-view.h, view.y));
}

function zoom(factor){
  if(!graph) return;
  const cx=view.x+view.w/2, cy=view.y+view.h/2;
  view.w*=factor; view.h*=factor;
  clampView();
  view.x=cx-view.w/2; view.y=cy-view.h/2;
  clampView();
  applyViewBox();
}

function centerOnSelected(){
  if(!graph || !selected || !graph.xy[selected]) return;
  const c=graph.xy[selected];
  const cx=c.x+graph.nodeW/2, cy=c.y+graph.nodeH/2;
  view.x=cx-view.w/2; view.y=cy-view.h/2;
  clampView();
  applyViewBox();
}

function drawGraph(){
  if(!graph) return;
  svg.innerHTML='';

  const {xy,nodeW,nodeH}=graph;

  // Layers: edges first, nodes on top. Edges are routed around cards,
  // and nodes remain visually clean/readable.
  const edgeLayer=document.createElementNS('http://www.w3.org/2000/svg','g');
  edgeLayer.setAttribute('data-layer','edges');
  edgeLayer.setAttribute('pointer-events','none');

  // === FAMILY COLOR PALETTE ===
  // Excluded: colors too similar to node colors (female:#f8b4d8 pink, male:#9cc8ff blue)
  // This ensures family lines never blend with node backgrounds
  const FAMILY_COLORS = [
    '#15803d', // —Ç—ë–º–Ω–æ-–∑–µ–ª—ë–Ω—ã–π (–∏–∑–±–µ–≥–∞–µ–º —Ä–æ–∑–æ–≤–æ–≥–æ, –≥–æ–ª—É–±–æ–≥–æ)
    '#dc2626', // —è—Ä–∫–æ-–∫—Ä–∞—Å–Ω—ã–π (–∫–æ–Ω—Ç—Ä–∞—Å—Ç–∏—Ä—É–µ—Ç —Å –æ–±–æ–∏–º–∏)
    '#7c3aed', // —Ñ–∏–æ–ª–µ—Ç–æ–≤—ã–π (—Ö–æ–ª–æ–¥–Ω—ã–π, –Ω–æ –Ω–µ –≥–æ–ª—É–±–æ–π)
    '#db2777', // –≥–ª—É–±–æ–∫–∏–π –ø—É—Ä–ø—É—Ä–Ω—ã–π-—Ä–æ–∑–æ–≤—ã–π (–Ω–æ –±–æ–ª–µ–µ —Ç—ë–º–Ω—ã–π, —á–µ–º —É–∑–ª—ã)
    '#0369a1', // –≥–ª—É–±–æ–∫–∏–π –≥–æ–ª—É–±–æ–π (—Ç—ë–º–Ω–µ–µ, —á–µ–º —É–∑–ª—ã)
    '#ea580c', // –æ—Ä–∞–Ω–∂–µ–≤—ã–π
    '#059669', // –∑–µ–ª—ë–Ω—ã–π (—Å—Ä–µ–¥–Ω–∏–π)
    '#ca8a04', // –∂—ë–ª—Ç–æ-–∫–æ—Ä–∏—á–Ω–µ–≤—ã–π
    '#9333ea', // —Å–≤–µ—Ç–ª—ã–π –ø—É—Ä–ø—É—Ä–Ω—ã–π
    '#0ea5e9', // –Ω–µ–±–µ—Å–Ω—ã–π –≥–æ–ª—É–±–æ–π (–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –æ—Ç–ª–∏—á–∞–µ—Ç—Å—è)
    '#d97706', // –æ—Ä–∞–Ω–∂–µ–≤–æ-–∫–æ—Ä–∏—á–Ω–µ–≤—ã–π
    '#6b21a8', // –æ—á–µ–Ω—å —Ç—ë–º–Ω—ã–π –ø—É—Ä–ø—É—Ä–Ω—ã–π
    '#065f46', // —Ç—ë–º–Ω–∞—è –±–∏—Ä—é–∑–∞
    '#7f1d1d', // —Ç—ë–º–Ω–æ-–∫—Ä–∞—Å–Ω—ã–π
    '#042f2e', // —Ç—ë–º–Ω–æ-–±–∏—Ä—é–∑–æ–≤—ã–π
    '#4c1d95', // –ø–ª–æ—Ç–Ω—ã–π –ø—É—Ä–ø—É—Ä–Ω—ã–π
    '#831843', // —Ç—ë–º–Ω—ã–π –ø—É—Ä–ø—É—Ä–Ω—ã–π-—Ä–æ–∑–æ–≤—ã–π
  ];

  // Build occupancy grid: for each level, list of {left,right} rectangles
  const occupancy = {};
  PEOPLE.forEach(p=>{
    const pos=xy[p.id]; if(!pos) return;
    const l = Math.round(pos.y); // approx level y
    if(!occupancy[l]) occupancy[l]=[];
    occupancy[l].push({left:pos.x, right:pos.x+nodeW, id:p.id});
  });

  // Build level Y ranges (nodeTop‚ÜínodeBottom) for collision detection
  const levelYRanges = {};
  PEOPLE.forEach(p=>{
    const pos=xy[p.id]; if(!pos) return;
    const ly = pos.y;
    if(!levelYRanges[ly]) levelYRanges[ly]={top:ly, bottom:ly+nodeH, nodes:[]};
    levelYRanges[ly].nodes.push({left:pos.x, right:pos.x+nodeW, id:p.id});
  });

  // Node rectangles for obstacle avoidance (exclude current family members when routing their own links).
  const nodeRects = PEOPLE.map(p=>{
    const pos=xy[p.id];
    if(!pos) return null;
    return {id:p.id, left:pos.x, right:pos.x+nodeW, top:pos.y, bottom:pos.y+nodeH};
  }).filter(Boolean);

  function verticalHitsNode(x, y1, y2, famMembers){
    const a=Math.min(y1,y2), b=Math.max(y1,y2);
    const pad=3;
    return nodeRects.some(n=>{
      if(famMembers?.has(n.id)) return false;
      const xHit = x > (n.left-pad) && x < (n.right+pad);
      const yHit = a < (n.bottom+pad) && b > (n.top-pad);
      return xHit && yHit;
    });
  }

  function horizontalHitsNode(y, x1, x2, famMembers){
    const a=Math.min(x1,x2), b=Math.max(x1,x2);
    const pad=3;
    return nodeRects.some(n=>{
      if(famMembers?.has(n.id)) return false;
      const yHit = y > (n.top-pad) && y < (n.bottom+pad);
      const xHit = a < (n.right+pad) && b > (n.left-pad);
      return xHit && yHit;
    });
  }

  // Find a clear vertical X channel that avoids nodes for the whole segment.
  function findClearChannel(fromY, toY, preferX, famMembers){
    if(!verticalHitsNode(preferX, fromY, toY, null)) return preferX;
    for(let d=8; d<graph.worldW; d+=6){
      const xl = preferX - d;
      if(xl > 4 && !verticalHitsNode(xl, fromY, toY, null)) return xl;
      const xr = preferX + d;
      if(xr < graph.worldW-4 && !verticalHitsNode(xr, fromY, toY, null)) return xr;
    }
    return preferX;
  }

  const INTO = 6;

  // === GLOBAL LANE REGISTRY: avoid overlaps/crossings between routed segments ===
  const usedYLanes = []; // [{y, x1, x2}] horizontal segments
  const usedXLanes = []; // [{x, y1, y2}] vertical segments

  function reserveYLane(y, x1, x2){
    usedYLanes.push({y, x1: Math.min(x1,x2), x2: Math.max(x1,x2)});
  }
  function reserveXLane(x, y1, y2){
    usedXLanes.push({x, y1: Math.min(y1,y2), y2: Math.max(y1,y2)});
  }

  function crossesVerticalLane(y, x1, x2){
    const a=Math.min(x1,x2), b=Math.max(x1,x2);
    const eps=0.2; // allow endpoint touching
    return usedXLanes.some(v => (v.x > a+eps && v.x < b-eps) && (y > v.y1+eps && y < v.y2-eps));
  }

  function crossesHorizontalLane(x, y1, y2){
    const a=Math.min(y1,y2), b=Math.max(y1,y2);
    const eps=0.2;
    return usedYLanes.some(h => (h.y > a+eps && h.y < b-eps) && (x > h.x1+eps && x < h.x2-eps));
  }

  function isYLaneFree(y, x1, x2, famMembers){
    const a=Math.min(x1,x2), b=Math.max(x1,x2);
    // Strict avoidance of parallel overlap (other horizontal lines on same Y)
    const lineFree = !usedYLanes.some(l => Math.abs(l.y - y) < 6 && l.x1 < b && a < l.x2);
    if(!lineFree) return false;
    
    // Allow orthogonal crossings (vertical lines cutting through this horizontal),
    // because blocking them makes routing impossible in dense graphs.
    // We only strictly block cutting through CARDS.
    return !horizontalHitsNode(y, a, b, null);
  }

  function findFreeYLane(preferY, x1, x2, minY, maxY, famMembers){
    const baseMin=Math.min(minY,maxY), baseMax=Math.max(minY,maxY);
    const hardMin=Math.max(2, baseMin - (nodeH + 22));
    const hardMax=Math.min(graph.worldH-2, baseMax + (nodeH + 22));

    // Try preferred Y first
    const start=Math.max(hardMin, Math.min(hardMax, preferY));
    if(isYLaneFree(start, x1, x2, famMembers)) return start;

    // Search outwards with wider step to prevent "stripe" clusters
    const step = 8; 
    for(let d=step; d < (hardMax-hardMin)+60; d+=step){
      const yUp = start - d;
      if(yUp >= hardMin && isYLaneFree(yUp, x1, x2, famMembers)) return yUp;
      const yDown = start + d;
      if(yDown <= hardMax && isYLaneFree(yDown, x1, x2, famMembers)) return yDown;
    }
    return start;
  }

  function isXLaneFree(x, y1, y2, famMembers){
    const a=Math.min(y1,y2), b=Math.max(y1,y2);
    // Strict avoidance of parallel overlap (other vertical lines on same X)
    const lineFree = !usedXLanes.some(l => Math.abs(l.x - x) < 6 && l.y1 < b && a < l.y2);
    if(!lineFree) return false;

    // Allow orthogonal crossings (horizontal lines cutting through this vertical)
    return !verticalHitsNode(x, a, b, null);
  }

  function findFreeXLane(preferX, y1, y2, famMembers){
    if(isXLaneFree(preferX, y1, y2, famMembers)) return preferX;
    for(let d=5; d < graph.worldW; d+=5){
      const xl = preferX - d;
      if(xl > 4 && isXLaneFree(xl, y1, y2, famMembers)) return xl;
      const xr = preferX + d;
      if(xr < graph.worldW-4 && isXLaneFree(xr, y1, y2, famMembers)) return xr;
    }
    return preferX;
  }

  // === ANCHOR OFFSET: when a person appears in multiple families, offset attachment points ===
  const anchorUsage = {};
  FAMS.forEach((f, fi)=>{
    const ps=[...(f.husband||[]), ...(f.wife||[])].filter(id=>xy[id]);
    const ch=(f.children||[]).filter(id=>xy[id]);
    if(!ps.length || !ch.length) return;
    ps.forEach(id=>{
      if(!anchorUsage[id]) anchorUsage[id]={asParent:[],asChild:[]};
      anchorUsage[id].asParent.push(fi);
    });
    ch.forEach(id=>{
      if(!anchorUsage[id]) anchorUsage[id]={asParent:[],asChild:[]};
      anchorUsage[id].asChild.push(fi);
    });
  });

  function getAnchorXOffset(personId, role, fi){
    const u = anchorUsage[personId];
    if(!u) return 0;
    const allFams = [...new Set([...u.asParent, ...u.asChild])];
    if(allFams.length <= 1) return 0;
    const idx = allFams.indexOf(fi);
    const total = allFams.length;
    const spread = Math.min(nodeW * 0.4, total * 10);
    return (idx - (total-1)/2) * (spread / Math.max(1, total-1));
  }

  // === COLOR ASSIGNMENT: Intersection-aware graph coloring ===
  // Calculate center X and Y range for each family
  const famBounds = FAMS.map((f, fi) => {
    const ps = [...(f.husband||[]), ...(f.wife||[])].filter(id=>xy[id]);
    const ch = (f.children||[]).filter(id=>xy[id]);
    if(!ps.length) return {fi, x: 0, yMin: 0, yMax: 0};
    
    const xs = ps.map(id => xy[id].x);
    const ys = [...ps, ...ch].map(id => xy[id].y);
    
    const centerX = (Math.min(...xs) + Math.max(...xs)) / 2;
    const yMin = Math.min(...ys);
    const yMax = Math.max(...ys) + nodeH;
    
    return {fi, x: centerX, yMin, yMax};
  });
  
  // Build conflict graph: families that have overlapping Y ranges are potential conflicts
  const conflicts = new Array(FAMS.length);
  for(let i = 0; i < FAMS.length; i++) conflicts[i] = new Set();
  
  for(let i = 0; i < FAMS.length; i++) {
    for(let j = i+1; j < FAMS.length; j++) {
      const f1 = famBounds[i];
      const f2 = famBounds[j];
      
      // Families conflict if their Y ranges overlap (potential for line crossing)
      if(f1.yMin < f2.yMax && f2.yMin < f1.yMax) {
        conflicts[i].add(j);
        conflicts[j].add(i);
      }
    }
  }
  
  // Greedy coloring: assign colors ensuring conflicting families have different colors
  const famColors = new Array(FAMS.length).fill(null);
  
  // Sort families by X position for consistent ordering
  const sortedIdx = famBounds.map((_, i) => i).sort((i, j) => famBounds[i].x - famBounds[j].x);
  
  sortedIdx.forEach(fi => {
    // Collect colors used by conflicting families
    const conflictColors = new Set();
    conflicts[fi].forEach(cf => {
      if(famColors[cf] !== null) conflictColors.add(famColors[cf]);
    });
    
    // Find first color not used by conflicts
    let colorIdx = 0;
    while(colorIdx < FAMILY_COLORS.length && conflictColors.has(FAMILY_COLORS[colorIdx])) {
      colorIdx++;
    }
    if(colorIdx >= FAMILY_COLORS.length) {
      colorIdx = (fi * 3) % FAMILY_COLORS.length;
    }
    
    famColors[fi] = FAMILY_COLORS[colorIdx];
  });

  FAMS.forEach((f, fi)=>{
    const ps=[...(f.husband||[]), ...(f.wife||[])].filter(id=>xy[id]);
    const ch=(f.children||[]).filter(id=>xy[id]);
    if(!ps.length || !ch.length) return;

    const color = famColors[fi];
    const famMembers = new Set([...ps, ...ch]);

    const famG=document.createElementNS('http://www.w3.org/2000/svg','g');
    famG.setAttribute('stroke', color);
    famG.setAttribute('fill','none');
    famG.setAttribute('stroke-width','2.5'); // —É–≤–µ–ª–∏—á–µ–Ω–æ —Å 1.8 –¥–ª—è –ª—É—á—à–µ–π –≤–∏–¥–∏–º–æ—Å—Ç–∏
    famG.setAttribute('stroke-linecap','round');
    famG.setAttribute('stroke-linejoin','round');
    famG.setAttribute('shape-rendering','geometricPrecision');

    const parentAnchors=ps.map(id=>({
      id,
      x:xy[id].x+nodeW/2+getAnchorXOffset(id,'parent',fi),
      yTop:xy[id].y,
      yBottom:xy[id].y+nodeH,
    }));
    const childAnchors=ch.map(id=>({
      id,
      x:xy[id].x+nodeW/2+getAnchorXOffset(id,'child',fi),
      yTop:xy[id].y,
      yBottom:xy[id].y+nodeH,
    }));

    const parentBottomEdge = Math.max(...ps.map(id=>xy[id].y+nodeH));
    const childTopEdge = Math.min(...ch.map(id=>xy[id].y));

    const hubX = (Math.min(...parentAnchors.map(a=>a.x)) + Math.max(...parentAnchors.map(a=>a.x))) / 2;

    // Estimate full X extents that bars will span (parents + hub + children)
    const allBarX = [...parentAnchors.map(a=>a.x), ...childAnchors.map(a=>a.x), hubX];
    const fullBarLeft = Math.min(...allBarX) - 10;
    const fullBarRight = Math.max(...allBarX) + 10;

    // Handle split-level families (where parents and children overlap in Y)
    // Use the actual vertical space available between parent anchors and child anchors
    const parentAnchorBottom = Math.max(...parentAnchors.map(a=>a.yBottom));
    const childAnchorTop = Math.min(...childAnchors.map(a=>a.yTop));
    const effectiveGapTop = Math.min(parentAnchorBottom, childAnchorTop);
    const effectiveGapBottom = Math.max(parentAnchorBottom, childAnchorTop);
    const gapMidpoint = (effectiveGapTop + effectiveGapBottom) / 2;
    
    // Find free Y lanes using the FULL bar extent so no cross-family overlap
    const preferYMid = effectiveGapTop + Math.min(14, (effectiveGapBottom - effectiveGapTop) * 0.3);
    const preferYChild = effectiveGapBottom - Math.min(14, (effectiveGapBottom - effectiveGapTop) * 0.3);
    
    const yMid = findFreeYLane(preferYMid, fullBarLeft, fullBarRight, effectiveGapTop, effectiveGapBottom, famMembers);
    const yChildBar = findFreeYLane(preferYChild, fullBarLeft, fullBarRight, effectiveGapTop, effectiveGapBottom, famMembers);

    // Detect multi-level gap: if there are intermediate levels with nodes between parents and children
    const multiLevel = (effectiveGapBottom - effectiveGapTop) > (nodeH + 40);
    
    // Store hubX for later use when drawing hub‚ÜíchildBar line
    let preferredHubX = hubX;
    parentAnchors.forEach(a=>{
      // Exit the card from the side closer to the selected lane.
      // But actually, we ALWAYS want to exit 'bottom' for parents typically.
      const startY = a.yBottom; 
      
      let clearance = 10;
      if(yMid < startY) clearance = -10; 
      if(Math.abs(yMid - startY) < Math.abs(clearance)) clearance = yMid - startY;
      
      const initialJogY = startY + clearance;
      
      // Calculate provisional ax for the initial jog level
      let ax = findFreeXLane(a.x, initialJogY, yMid, famMembers);

      // Snap to exact card alignment if close (avoids micro-jogs/serrations)
      if(Math.abs(ax - a.x) < 4) ax = a.x;

      // 2. Find clean horizontal lane for the jog using provisional ax
      const safeJogY = findFreeYLane(initialJogY, a.x, ax, startY-30, startY+30, famMembers);
      
      // Refine ax if jogY moved significantly
      if(Math.abs(safeJogY - initialJogY) > 1){
         ax = findFreeXLane(a.x, safeJogY, yMid, famMembers);
         if(Math.abs(ax - a.x) < 4) ax = a.x;
      }
      
      // Optimization: if straight vertical is possible, draw single continuous line
      if(Math.abs(ax - a.x) < 0.2){
        const line=document.createElementNS('http://www.w3.org/2000/svg','line');
        line.setAttribute('x1',ax); line.setAttribute('y1',startY);
        line.setAttribute('x2',ax); line.setAttribute('y2',yMid);
        famG.appendChild(line);
        reserveXLane(ax, startY, yMid);
        a._ax = ax;
        return;
      }

      // 1. Vertical stub out of card
      if(Math.abs(safeJogY - startY) > 0.1){
        const stub = document.createElementNS('http://www.w3.org/2000/svg','line');
        stub.setAttribute('x1', a.x); stub.setAttribute('y1', startY);
        stub.setAttribute('x2', a.x); stub.setAttribute('y2', safeJogY);
        famG.appendChild(stub);
        reserveXLane(a.x, startY, safeJogY);
      }

      // 2. Horizontal jog
      if(Math.abs(ax - a.x) > 0.2){
        const jog=document.createElementNS('http://www.w3.org/2000/svg','line');
        jog.setAttribute('x1',a.x); jog.setAttribute('y1',safeJogY);
        jog.setAttribute('x2',ax);  jog.setAttribute('y2',safeJogY);
        famG.appendChild(jog);
        reserveYLane(safeJogY, a.x, ax);
      }

      // 3. Main vertical drop
      if(Math.abs(yMid - safeJogY) > 0.1){
        const line=document.createElementNS('http://www.w3.org/2000/svg','line');
        line.setAttribute('x1',ax); line.setAttribute('y1',safeJogY);
        line.setAttribute('x2',ax); line.setAttribute('y2',yMid);
        famG.appendChild(line);
        reserveXLane(ax, safeJogY, yMid);
      }
      
      a._ax = ax; // store adjusted X for bar
    });
    if(parentAnchors.length>1){
      const h=document.createElementNS('http://www.w3.org/2000/svg','line');
      const pxs = parentAnchors.map(a=>a._ax||a.x);
      const pLeft=Math.min(...pxs), pRight=Math.max(...pxs);
      h.setAttribute('x1', pLeft);
      h.setAttribute('x2', pRight);
      h.setAttribute('y1', yMid); h.setAttribute('y2', yMid);
      famG.appendChild(h);
      reserveYLane(yMid, pLeft, pRight);
    }

    // Marriage dot
    const dot=document.createElementNS('http://www.w3.org/2000/svg','circle');
    dot.setAttribute('cx',hubX); dot.setAttribute('cy',yMid);
    dot.setAttribute('r','3');
    dot.setAttribute('fill',color);
    famG.appendChild(dot);

    // === HUB ‚Üí CHILDREN with obstacle avoidance ===
    let hubEndX = hubX;
    if(multiLevel){
      const channelX = findClearChannel(yMid, yChildBar, hubX, famMembers);
      const freeChX = findFreeXLane(channelX, yMid, yChildBar, famMembers);
      hubEndX = freeChX;

      const path=document.createElementNS('http://www.w3.org/2000/svg','polyline');
      const pts = [
        `${hubX},${yMid}`,
        `${freeChX},${yMid}`,
        `${freeChX},${yChildBar}`,
      ];
      path.setAttribute('points', pts.join(' '));
      famG.appendChild(path);
      if(Math.abs(freeChX - hubX) > 0.2) reserveYLane(yMid, hubX, freeChX);
      reserveXLane(freeChX, yMid, yChildBar);
    } else {
      // Direct: hub ‚Üí childBar
      // Try to go straight down from hubX first; only deviate if blocked
      let freeHubX = hubX;
      if(!isXLaneFree(hubX, yMid, yChildBar, famMembers)) {
        freeHubX = findFreeXLane(hubX, yMid, yChildBar, famMembers);
      }
      hubEndX = freeHubX;
      const vDown=document.createElementNS('http://www.w3.org/2000/svg','line');
      vDown.setAttribute('x1',freeHubX); vDown.setAttribute('y1',yMid);
      vDown.setAttribute('x2',freeHubX); vDown.setAttribute('y2',yChildBar);
      famG.appendChild(vDown);
      reserveXLane(freeHubX, yMid, yChildBar);
    }

    // Horizontal bar across children + connect to routing
    const allX = childAnchors.map(a=>a.x);
    allX.push(hubEndX);
    const barLeft = Math.min(...allX);
    const barRight = Math.max(...allX);
    if(barLeft !== barRight){
      const hBar=document.createElementNS('http://www.w3.org/2000/svg','line');
      hBar.setAttribute('x1', barLeft); hBar.setAttribute('x2', barRight);
      hBar.setAttribute('y1', yChildBar); hBar.setAttribute('y2', yChildBar);
      famG.appendChild(hBar);
      reserveYLane(yChildBar, barLeft, barRight);
    }

    // Each child: vertical from bar into node.
    childAnchors.forEach(a=>{
      const endY = a.yTop; 
      
      let clearance = -10; 
      if(yChildBar > endY) clearance = 10;
      if(Math.abs(yChildBar - endY) < Math.abs(clearance)) clearance = yChildBar - endY;
      
      const initialJogY = endY + clearance;
      
      // Calculate provisional ax for the initial jog level
      let ax = findFreeXLane(a.x, yChildBar, initialJogY, famMembers);

      // Snap to exact card alignment if close (avoids micro-jogs/serrations)
      if(Math.abs(ax - a.x) < 4) ax = a.x;

      // Find a clean Y-lane for the jog (refine Y)
      const safeJogY = findFreeYLane(initialJogY, a.x, ax, endY-30, endY+30, famMembers);

      // Re-calculate ax for the final safeJogY if it changed significantly
      if(Math.abs(safeJogY - initialJogY) > 1){
         ax = findFreeXLane(a.x, yChildBar, safeJogY, famMembers);
         if(Math.abs(ax - a.x) < 4) ax = a.x;
      }

      // Optimization: if straight vertical is possible, draw single continuous line
      if(Math.abs(ax - a.x) < 0.2){
        const line=document.createElementNS('http://www.w3.org/2000/svg','line');
        line.setAttribute('x1',ax); line.setAttribute('y1',yChildBar);
        line.setAttribute('x2',ax); line.setAttribute('y2',endY);
        famG.appendChild(line);
        reserveXLane(ax, yChildBar, endY);
        return;
      }

      // 1. Main vertical drop from bar
      if(Math.abs(safeJogY - yChildBar) > 0.1){
        const line=document.createElementNS('http://www.w3.org/2000/svg','line');
        line.setAttribute('x1',ax); line.setAttribute('y1',yChildBar);
        line.setAttribute('x2',ax); line.setAttribute('y2',safeJogY);
        famG.appendChild(line);
        reserveXLane(ax, yChildBar, safeJogY);
      }

      // 2. Horizontal jog
      if(Math.abs(ax - a.x) > 0.2){
        const jog=document.createElementNS('http://www.w3.org/2000/svg','line');
        jog.setAttribute('x1',ax);  jog.setAttribute('y1',safeJogY);
        jog.setAttribute('x2',a.x); jog.setAttribute('y2',safeJogY);
        famG.appendChild(jog);
        reserveYLane(safeJogY, ax, a.x);
      }

      // 3. Vertical stub into card
      if(Math.abs(endY - safeJogY) > 0.1){
        const stub = document.createElementNS('http://www.w3.org/2000/svg','line');
        stub.setAttribute('x1', a.x); stub.setAttribute('y1', safeJogY);
        stub.setAttribute('x2', a.x); stub.setAttribute('y2', endY);
        famG.appendChild(stub);
        reserveXLane(a.x, safeJogY, endY);
      }
    });

    edgeLayer.appendChild(famG);
  });

  const nodes=document.createElementNS('http://www.w3.org/2000/svg','g');
  PEOPLE.forEach(p=>{
    const pos=xy[p.id]; if(!pos) return;
    const g=document.createElementNS('http://www.w3.org/2000/svg','g');
    g.classList.add('node'); g.dataset.id=p.id;

    const isKey=['I1','I7','I16','I17'].includes(p.id);
    const isMention=['I135','I263','I265','I268'].includes(p.id);

    let fill='var(--node)', stroke='var(--node-stroke)';
    if(isKey){ fill='var(--node-key)'; stroke='var(--node-key-stroke)'; }
    else if(isMention){ fill='var(--node-mention)'; stroke='var(--node-mention-stroke)'; }
    else if((p.sex||'').toUpperCase()==='M'){ fill='var(--male)'; stroke='var(--male-stroke)'; }
    else if((p.sex||'').toUpperCase()==='F'){ fill='var(--female)'; stroke='var(--female-stroke)'; }

    const rect=document.createElementNS('http://www.w3.org/2000/svg','rect');
    rect.setAttribute('x',pos.x); rect.setAttribute('y',pos.y);
    rect.setAttribute('width',nodeW); rect.setAttribute('height',nodeH);
    rect.setAttribute('fill',fill); rect.setAttribute('stroke',stroke);
    g.appendChild(rect); // Background first

    const [l1, l2, l3] = splitName3(p.name||p.name_raw,p.id, Math.max(8, Math.floor((nodeW-6)/7)));
    const yy=years(p);
    
    // Layout: emoji + 3 lines of text + years.
    // Base Y is pos.y + 12 (padding top). Line height ~10.
    const startY = pos.y + 13;
    const lh = 10;
    
    // Emoji on top
    const tEmoji=document.createElementNS('http://www.w3.org/2000/svg','text');
    tEmoji.setAttribute('x',pos.x+nodeW/2); tEmoji.setAttribute('y',startY-3);
    tEmoji.setAttribute('font-size', '11');
    tEmoji.setAttribute('text-anchor','middle');
    tEmoji.textContent=p.emoji || 'üë§';
    g.appendChild(tEmoji);
    
    const t1=document.createElementNS('http://www.w3.org/2000/svg','text');
    t1.setAttribute('x',pos.x+nodeW/2); t1.setAttribute('y',startY+8);
    t1.setAttribute('font-size', '9.5');
    t1.setAttribute('text-anchor','middle');
    t1.setAttribute('fill','#121a27');
    t1.textContent=l1;
    g.appendChild(t1);

    if(l2){
      const t2=document.createElementNS('http://www.w3.org/2000/svg','text');
      t2.setAttribute('x',pos.x+nodeW/2); t2.setAttribute('y',startY+lh+8);
      t2.setAttribute('font-size', '9.5');
      t2.setAttribute('text-anchor','middle');
      t2.setAttribute('fill','#121a27');
      t2.textContent=l2;
      g.appendChild(t2);
    }

    if(l3){
      const t3=document.createElementNS('http://www.w3.org/2000/svg','text');
      t3.setAttribute('x',pos.x+nodeW/2); t3.setAttribute('y',startY+lh*2+8);
      t3.setAttribute('font-size', '9.5');
      t3.setAttribute('text-anchor','middle');
      t3.setAttribute('fill','#121a27');
      t3.textContent=l3;
      g.appendChild(t3);
    }

    const tY=document.createElementNS('http://www.w3.org/2000/svg','text');
    tY.setAttribute('x',pos.x+nodeW/2); tY.setAttribute('y',pos.y+nodeH-7);
    tY.setAttribute('text-anchor','middle');
    tY.setAttribute('font-size', '9.0');
    tY.setAttribute('fill','#314764');
    tY.textContent=yy || '';
    g.appendChild(tY);
    
    // Add title (tooltip)
    const title=document.createElementNS('http://www.w3.org/2000/svg','title');
    title.textContent=`${p.emoji} ${(p.name||p.name_raw||p.id).replaceAll('/','').trim()}${yy?(' ¬∑ '+yy):''}`;
    g.appendChild(title);
    
    g.onclick=()=>select(p.id,true);
    nodes.appendChild(g);
  });

  svg.appendChild(edgeLayer);
  svg.appendChild(nodes);
  applyViewBox();
  highlightSelected();
}

function highlightSelected(){
  svg.querySelectorAll('.node rect').forEach(r=>r.setAttribute('stroke-width','1.4'));
  if(!selected) return;
  const n=svg.querySelector(`.node[data-id='${selected}'] rect`);
  if(n){ n.setAttribute('stroke','#ef4444'); n.setAttribute('stroke-width','3'); }
}

function select(id,center=false){
  selected=id;
  renderDetails(id);
  renderList(PEOPLE);
  highlightSelected();
  if(center) centerOnSelected();
}

function bindGraphInteractions(){
  let dragging=false, start=null, startView=null;

  // Inertia variables
  let vx = 0, vy = 0;
  let lastMoveTime = 0;
  let inertiaRaf = 0;

  function stopInertia() {
    if (inertiaRaf) {
      cancelAnimationFrame(inertiaRaf);
      inertiaRaf = 0;
    }
    vx = 0;
    vy = 0;
  }

  function applyInertia() {
    if (Math.abs(vx) < 0.1 && Math.abs(vy) < 0.1) {
      stopInertia();
      return;
    }
    
    // Friction factor
    vx *= 0.95;
    vy *= 0.95;

    // Convert pixel velocity to SVG view units based on current zoom
    const scaleX = view.w / host.clientWidth;
    const scaleY = view.h / host.clientHeight;

    view.x -= vx * scaleX;
    view.y -= vy * scaleY;
    
    clampView();
    applyViewBox();
    
    inertiaRaf = requestAnimationFrame(applyInertia);
  }

  svg.addEventListener('mousedown',(e)=>{
    if(e.button!==0) return;
    stopInertia(); // Stop any existing movement
    dragging=true;
    start={x:e.clientX,y:e.clientY};
    startView={...view};
    lastMoveTime = Date.now();
    vx = 0; vy = 0;
  });

  window.addEventListener('mousemove',(e)=>{
    if(!dragging) return;
    const now = Date.now();
    
    // Skip if too frequent (throttle?) No, we need smooth.
    // But we need accurate dt.
    const dt = now - lastMoveTime;
    
    // Only update velocity if enough time passed or movement happened
    const currentX = e.clientX;
    const currentY = e.clientY;
    
    const dx = currentX - prevMouse.x;
    const dy = currentY - prevMouse.y;
    
    // Calculate instantaneous velocity (pixels per 16ms frame)
    if (dt > 0) {
      // Current raw velocity
      const rawVx = dx;
      const rawVy = dy;
      
      // Simple exponential smoothing to reduce jitter
      // 0.4 * new + 0.6 * old
      vx = vx * 0.6 + rawVx * 0.4;
      vy = vy * 0.6 + rawVy * 0.4;
      
      lastMoveTime = now;
    }
    
    prevMouse = {x: currentX, y: currentY};
    
    // Update view position based on absolute delta from start
    // This prevents drift.
    const scaleX = startView.w / host.clientWidth;
    const scaleY = startView.h / host.clientHeight;
    
    const totalDx = currentX - start.x;
    const totalDy = currentY - start.y;
    
    view.x = startView.x - totalDx * scaleX;
    view.y = startView.y - totalDy * scaleY;
    
    clampView();
    applyViewBox();
  });
  
  // Re-implement mousemove to support velocity tracking
  let prevMouse = {x:0, y:0};

  svg.addEventListener('mousedown',(e)=>{
    if(e.button!==0) return;
    stopInertia();
    dragging=true;
    start={x:e.clientX,y:e.clientY};
    prevMouse={x:e.clientX, y:e.clientY};
    startView={...view};
    vx = 0; vy = 0;
    lastMoveTime = Date.now();
  });

  window.addEventListener('mousemove',(e)=>{
    if(!dragging) return;
    e.preventDefault();
    const now = Date.now();
    const dt = now - lastMoveTime;
    
    const currentX = e.clientX;
    const currentY = e.clientY;
    
    // Velocity = movement since last event
    const dx = currentX - prevMouse.x;
    const dy = currentY - prevMouse.y;
    
    // update view
    const scaleX = startView.w / host.clientWidth;
    const scaleY = startView.h / host.clientHeight;
    
    // We can't just use dx/dy incrementally because floating point errors accumulate.
    // We must stick to: view = startView - totalDelta.
    const totalDx = currentX - start.x;
    const totalDy = currentY - start.y;
    view.x = startView.x - totalDx * scaleX;
    view.y = startView.y - totalDy * scaleY;
    
    clampView();
    applyViewBox();

    // Track velocity for inertia
    // Smooth it a bit?
    // If dt is huge, velocity is small?
    // Let's just store the raw pixel delta as "velocity per event"
    // But we need to decay it if user stops moving while holding.
    if (dt > 0) {
      // Simple moving average or just last delta?
      // Last delta is fine for simple throw.
      vx = dx;
      vy = dy;
      lastMoveTime = now;
    }
    
    prevMouse = {x: currentX, y: currentY};
  });

  window.addEventListener('mouseup', () => {
    if(!dragging) return;
    dragging=false;
    // Start inertia only if last move was recent (<50ms)
    // And velocity is significant
    if (Date.now() - lastMoveTime < 50 && (Math.abs(vx) > 1.5 || Math.abs(vy) > 1.5)) {
      applyInertia();
    } else {
      vx=0; vy=0;
    }
  });


  // Touch support (Pan + Pinch)
  let touchStartDist = 0;
  let touchStartView = null;
  let touchStartCenter = null;
  let lastTapTime = 0;
  let isDrag = false;

  // Prevent Safari gesture events (zoom rubber-banding)
  host.addEventListener('gesturestart', e => e.preventDefault());
  host.addEventListener('gesturechange', e => e.preventDefault());
  host.addEventListener('gestureend', e => e.preventDefault());

  host.addEventListener('touchstart', (e) => {
    if (e.touches.length === 1) {
      stopInertia();
      dragging = true;
      isDrag = false;
      start = { x: e.touches[0].clientX, y: e.touches[0].clientY };
      prevMouse = { x: e.touches[0].clientX, y: e.touches[0].clientY };
      startView = { ...view };
      lastMoveTime = Date.now();
      vx = 0; vy = 0;
    } else if (e.touches.length === 2) {
      stopInertia();
      dragging = false;
      isDrag = false;
      const t1 = e.touches[0];
      const t2 = e.touches[1];
      touchStartDist = Math.hypot(t2.clientX - t1.clientX, t2.clientY - t1.clientY);
      touchStartView = { ...view };
      touchStartCenter = {
        x: (t1.clientX + t2.clientX) / 2,
        y: (t1.clientY + t2.clientY) / 2
      };
    }
  }, { passive: false });

  host.addEventListener('touchmove', (e) => {
    // Only prevent default if we are actively interacting (not standard taps)
    if (dragging || touchStartDist > 0) {
      if (e.cancelable) e.preventDefault();
    }
    const now = Date.now();
    
    if (e.touches.length === 1 && dragging) {
      const currentX = e.touches[0].clientX;
      const currentY = e.touches[0].clientY;
      const dxPx = currentX - start.x;
      const dyPx = currentY - start.y;
      
      if(Math.abs(dxPx) > 5 || Math.abs(dyPx) > 5) isDrag = true;

      const scaleX = startView.w / host.clientWidth;
      const scaleY = startView.h / host.clientHeight;
      view.x = startView.x - dxPx * scaleX;
      view.y = startView.y - dyPx * scaleY;
      clampView();
      applyViewBox();
      
      // Velocity tracking for inertia
      const dt = now - lastMoveTime;
      const dx = currentX - prevMouse.x;
      const dy = currentY - prevMouse.y;
      
      if(dt > 0) {
        // Calculate velocity (px per 16ms frame)
        // If dt is tiny, velocity might spike. If dt is huge, velocity drops.
        // We want a rolling average.
        const rawVx = dx;
        const rawVy = dy;
        
        // Use simpler smoothing for touch: 0.5/0.5
        // Touch events fire often.
        vx = vx * 0.5 + rawVx * 0.5;
        vy = vy * 0.5 + rawVy * 0.5;

        lastMoveTime = now;
      }
      prevMouse = {x: currentX, y: currentY};

    } else if (e.touches.length === 2 && touchStartDist > 0) {
      if (e.cancelable) e.preventDefault();
      
      const t1 = e.touches[0];
      const t2 = e.touches[1];
      const dist = Math.hypot(t2.clientX - t1.clientX, t2.clientY - t1.clientY);
      const center = {
        x: (t1.clientX + t2.clientX) / 2,
        y: (t1.clientY + t2.clientY) / 2
      };

      const scale = touchStartDist / dist;
      const newW = touchStartView.w * scale;
      const newH = touchStartView.h * scale;

      const rect = host.getBoundingClientRect();
      const oldScreenX = touchStartCenter.x - rect.left;
      const oldScreenY = touchStartCenter.y - rect.top;
      
      const oldSvgX = touchStartView.x + oldScreenX * (touchStartView.w / host.clientWidth);
      const oldSvgY = touchStartView.y + oldScreenY * (touchStartView.h / host.clientHeight);

      const newScreenX = center.x - rect.left;
      const newScreenY = center.y - rect.top;

      view.w = newW;
      view.h = newH;
      view.x = oldSvgX - newScreenX * (newW / host.clientWidth);
      view.y = oldSvgY - newScreenY * (newH / host.clientHeight);

      clampView();
      applyViewBox();
    }
  }, { passive: false });

  host.addEventListener('touchend', (e) => {
    // If transitioning 2->1 fingers, don't just stop everything.
    // But keeping it simple for now to avoid jumpiness.
    // Main fix: handle 2-finger lift correctly without snapback.
    
    if (touchStartDist > 0 && e.touches.length < 2) {
       // Pinch ended. Reset pinch state but don't start inertia immediately.
       dragging = false;
       touchStartDist = 0;
       return; 
    }

    dragging = false;
    touchStartDist = 0;

    // Start inertia if velocity is significant and recent
    // Use slightly larger threshold for touch (more noise)
    if (isDrag && (Date.now() - lastMoveTime) < 80) { // increased to 80ms
      if (Math.abs(vx) > 1.5 || Math.abs(vy) > 1.5) {
        applyInertia();
      } else {
        vx=0; vy=0;
      }
    } else {
      vx=0; vy=0;
    }

    // Custom double-tap detection for touch devices
    if (!isDrag && e.changedTouches.length > 0) {
       const now = Date.now();
       if (now - lastTapTime < 400) {
         if(e.target.closest('button, input, a, .node')) {
           lastTapTime = 0; 
           return;
         }
         e.preventDefault();
         const t = e.changedTouches[0];
         doZoomAt(t.clientX, t.clientY);
         lastTapTime = 0; 
       } else {
         lastTapTime = now;
       }
    }
  });

  function doZoomAt(clientX, clientY){
    const rect = host.getBoundingClientRect();
    const clickX = clientX - rect.left;
    const clickY = clientY - rect.top;

    // Convert screen pixel to SVG unit
    const scaleX = view.w / host.clientWidth;
    const scaleY = view.h / host.clientHeight;
    const svgX = view.x + clickX * scaleX;
    const svgY = view.y + clickY * scaleY;

    // Zoom in 2x
    const factor = 0.5;
    const newW = view.w * factor;
    const newH = view.h * factor;

    view.x = svgX - newW / 2;
    view.y = svgY - newH / 2;
    view.w = newW;
    view.h = newH;

    clampView();
    applyViewBox();
  }

  // Deterministic trackpad behavior:
  // - 2-finger scroll = PAN
  // - zoom only on explicit Ctrl+wheel/pinch signal
  // This avoids random mode switching on noisy gesture streams.
  function normalizeWheelDelta(e){
    let dx=e.deltaX, dy=e.deltaY;
    if(e.deltaMode===1){ // lines
      dx*=16; dy*=16;
    } else if(e.deltaMode===2){ // pages
      dx*=host.clientWidth;
      dy*=host.clientHeight;
    }
    return {dx,dy};
  }

  let wheelMode='pan';
  let wheelModeUntil=0;
  let pendingPanX=0, pendingPanY=0, panRaf=0;

  function flushPan(){
    panRaf=0;
    if(!pendingPanX && !pendingPanY) return;
    view.x += pendingPanX;
    view.y += pendingPanY;
    pendingPanX=0; pendingPanY=0;
    clampView();
    applyViewBox();
  }

  host.addEventListener('wheel',(e)=>{
    e.preventDefault();
    e.stopPropagation();

    const now=performance.now();
    const {dx,dy}=normalizeWheelDelta(e);
    if(Math.abs(dx)<0.01 && Math.abs(dy)<0.01) return;

    const wantsZoom = !!e.ctrlKey; // keep strict: Ctrl/pinch only

    // Lock interaction mode for a short burst to prevent flicker pan<->zoom.
    if(now > wheelModeUntil){
      wheelMode = wantsZoom ? 'zoom' : 'pan';
    } else if(wheelMode==='zoom' && !wantsZoom){
      // Keep zoom mode until burst ends.
    } else if(wheelMode==='pan' && wantsZoom){
      // Only switch to zoom in-burst for clearly zoom-like movement.
      if(Math.abs(dy) > Math.abs(dx)*1.25) wheelMode='zoom';
    }
    wheelModeUntil = now + (wheelMode==='zoom' ? 180 : 120);

    if(wheelMode==='zoom'){
      const strength=Math.min(1.7, Math.max(0.6, Math.abs(dy)/140));
      const factor = dy<0 ? (1 - 0.14*strength) : (1 + 0.14*strength);
      zoom(Math.max(0.78, Math.min(1.24, factor)));
      return;
    }

    // Pan path (scheduled on RAF to avoid choppy delayed response).
    const panBoost=1.45;
    const scaleX=(view.w/host.clientWidth)*panBoost;
    const scaleY=(view.h/host.clientHeight)*panBoost;
    pendingPanX += dx * scaleX;
    pendingPanY += dy * scaleY;
    if(!panRaf) panRaf=requestAnimationFrame(flushPan);
  }, {passive:false});

  host.addEventListener('dblclick', (e) => {
    // Ignore double click on interactive elements
    if(e.target.closest('button, input, a, .node')) return;
    
    e.preventDefault();
    doZoomAt(e.clientX, e.clientY);
  });

  fitBtn.onclick=()=>fitView();
  zoomInBtn.onclick=()=>zoom(0.88);
  zoomOutBtn.onclick=()=>zoom(1.14);
  centerBtn.onclick=()=>centerOnSelected();

  window.addEventListener('resize',()=>{
    // keep same center while resizing
    const cx=view.x+view.w/2, cy=view.y+view.h/2;
    drawGraph();
    view.x=cx-view.w/2; view.y=cy-view.h/2;
    clampView();
    applyViewBox();
    renderVersionInfo();
  });
}

async function init(){
  const r=await fetch('data.json');
  DATA=await r.json();
  PEOPLE=DATA.people;
  FAMS=DATA.families;
  MAP=Object.fromEntries(PEOPLE.map(p=>[p.id,p]));

  elMeta.textContent=`–õ—é–¥–µ–π: ${DATA.meta.people_count} ¬∑ –°–µ–º–µ–π: ${DATA.meta.families_count} ¬∑ ${DATA.meta.generator}`;
  renderVersionInfo();
  setInterval(renderVersionInfo, 60000);

  renderList(PEOPLE);
  buildGraphModel();
  fitView();
  drawGraph();
  bindGraphInteractions();

  const start = MAP['I1'] ? 'I1' : PEOPLE[0]?.id;
  if(start) select(start,true);

  elQ.oninput=()=>{
    const q=elQ.value.trim();
    const qLower=q.toLowerCase();
    const arr=!q ? PEOPLE : PEOPLE.filter(p=>`${p.emoji} ${p.name} ${p.name_raw} ${p.surname} ${p.given}`.toLowerCase().includes(qLower));
    renderList(arr);
  };
}

init().catch(err=>{
  console.error(err);
  elMeta.textContent='–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ data.json';
});
</script>
</body>
</html>
